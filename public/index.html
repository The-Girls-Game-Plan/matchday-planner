<!DOCTYPE html>
<html>
<head>
    <title>The Girls' Game Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom CSS to ensure default fonts and layout */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* Custom scrollbar style for player lists */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #56B0D5; /* SKY_BLUE */
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: #f0f4f8;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Global utility to generate unique IDs
        const generateUUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        // Mock components for Lucide icons 
        const User = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1rem', height: '1rem'}}>👤</span>;
        const Settings = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.5rem', height: '1.5rem'}}>⚙️</span>;
        const Play = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.25rem', height: '1.25rem'}}>▶️</span>;
        const Save = ({ className = '', style = {}, color = 'currentColor' }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.25rem', height: '1.25rem', color}}>💾</span>;
        const Unlock = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1rem', height: '1rem'}}>🔑</span>;
        const Loader2 = ({ className = '', style = {} }) => <span className={`${className} animate-spin`} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.25rem', height: '1.25rem'}}>🔄</span>;
        const Star = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1rem', height: '1rem'}}>⭐</span>;


        const { useState, useEffect, useMemo, useCallback } = React;
        
        // --- MOCK FIREBASE LIBRARIES (FOR SINGLE-FILE EXECUTION) ---
        window.__app_id = 'mock-app';
        window.__firebase_config = JSON.stringify({ apiKey: "mock-key", authDomain: "mock-domain", projectId: "mock-project" });
        window.__initial_auth_token = 'mock-token';

        const mockDbData = new Map();

        const retryFetch = async (apiCall, maxRetries = 1) => {
            return await apiCall();
        };

        const getPrivatePath = (collectionName, userId) => {
            const appId = window.__app_id || 'default-app-id';
            return `mock_db:${appId}:${userId}:${collectionName}`;
        };

        const useFirebase = () => {
            const [userId] = useState('mock-user-12345');
            const [isAuthReady] = useState(true);
            const [error] = useState(null);

            const mockFirestore = useMemo(() => ({
                collection: (path) => ({ path }),
                query: (collectionRef) => ({ ...collectionRef }),
                getDocs: async (q) => {
                    const prefix = `${q.path}:`;
                    const docs = Array.from(mockDbData.entries())
                        .filter(([key]) => key.startsWith(prefix))
                        .map(([key, value]) => ({
                            id: key.split(':').pop(),
                            data: () => value
                        }));
                    return { docs };
                },
                doc: (collectionRef, id = generateUUID()) => ({ path: collectionRef.path, id }),
                setDoc: async (docRef, data) => {
                    mockDbData.set(`${docRef.path}:${docRef.id}`, data);
                },
                deleteDoc: async (docRef) => {
                    mockDbData.delete(`${docRef.path}:${docRef.id}`);
                }
            }), []);


            const firestorePath = useMemo(() => {
                if (userId) {
                    return getPrivatePath('squads', userId);
                }
                return null;
            }, [userId]);

            return { db: mockFirestore, userId, isAuthReady, firestorePath, appId: window.__app_id, error };
        };


        // --- CONFIGURATION & CONSTANTS ---

        const COLORS = {
          NAVY_BLUE: '#193755', 
          ORANGE: '#E97227', 
          SKY_BLUE: '#56B0D5', 
          WHITE: '#FFFFFF',
          GOLD: '#AF9542', 
        };

        const MATCH_DURATIONS = {
          '5v5': 40,
          '7v7': 50,
          '9v9': 60,
          '11v11': 70, 
        };

        // --- UPDATED FORMATIONS STRUCTURE ---
        const FORMATIONS = {
            '5v5': [
                { name: '1-2-1', slots: ['CD', 'CM-R', 'CM-L', 'ST'], maxPlayers: 4 },
                { name: '2-1-1', slots: ['CD-R', 'CD-L', 'CM', 'ST'], maxPlayers: 4 },
                { name: '1-1-2', slots: ['CD', 'CM', 'ST-R', 'ST-L'], maxPlayers: 4 },
            ],
            '7v7': [
                { name: '2-1-3', slots: ['CD-R', 'CD-L', 'CM', 'ST-R', 'ST-L', 'ST'], maxPlayers: 6 },
                { name: '2-2-2', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'ST-R', 'ST-L'], maxPlayers: 6 },
                { name: '1-3-2', slots: ['CD', 'CM-R', 'CM-L', 'CM', 'ST-R', 'ST-L'], maxPlayers: 6 },
                { name: '2-3-1', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'CM', 'ST'], maxPlayers: 6 },
                { name: '1-2-3', slots: ['CD', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'ST'], maxPlayers: 6 },
                { name: '1-4-1', slots: ['CD', 'CM-R', 'CM-L', 'RW', 'LW', 'ST'], maxPlayers: 6 },
            ],
            '9v9': [
                { name: '3-2-3', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'ST'], maxPlayers: 8 },
                { name: '3-3-2', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'CDM', 'ST-R', 'ST-L'], maxPlayers: 8 },
                { name: '3-4-1', slots: ['CD-R', 'CD-L', 'CD', 'RB', 'LB', 'CM', 'CDM', 'ST'], maxPlayers: 8 },
                { name: '3-2-1-2', slots: ['CD-R', 'CD-L', 'CD', 'CDM-R', 'CDM-L', 'CAM', 'ST-R', 'ST-L'], maxPlayers: 8 },
                { name: '2-4-2', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'CDM', 'CAM', 'ST-R', 'ST-L'], maxPlayers: 8 },
                { name: '2-3-3', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'CDM', 'ST-R', 'ST-L', 'ST'], maxPlayers: 8 },
                { name: '2-2-4', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'RW', 'LW'], maxPlayers: 8 },
            ],
            '11v11': [
                { name: '4-4-2', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'RW', 'LW', 'CM-R', 'CM-L', 'ST-R', 'ST-L'], maxPlayers: 10 },
                { name: '4-3-3', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CM-R', 'CM-L', 'CDM', 'RW', 'LW', 'ST'], maxPlayers: 10 },
                { name: '4-2-3-1', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CDM-R', 'CDM-L', 'RW', 'LW', 'CAM', 'ST'], maxPlayers: 10 },
                { name: '4-1-4-1', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CDM', 'CM-R', 'CM-L', 'RW', 'LW', 'ST'], maxPlayers: 10 },
                { name: '4-2-4', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'RW', 'LW'], maxPlayers: 10 },
                { name: '3-5-2', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'CDM', 'CAM', 'RW', 'ST-R', 'ST-L'], maxPlayers: 10 },
                { name: '3-4-3', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'CDM', 'CAM', 'RW', 'LW', 'ST'], maxPlayers: 10 },
            ],
        };

        const ALL_POSITIONS = [
          'GK', 'CD', 'CD-R', 'CD-L', 'RB', 'LB', 'CM', 'CM-R', 'CM-L',
          'CDM', 'CAM', 'RW', 'LW', 'ST', 'ST-R', 'ST-L'
        ];
        
        // --- CORE MATCH PLANNER LOGIC ---

        const getOutfieldSlots = (gameFormat, selectedFormation) => {
            const formatArray = FORMATIONS[gameFormat];
            const formation = formatArray ? formatArray.find(f => f.name === selectedFormation) : null;
            return formation ? formation.slots : [];
        };

        const getOutfieldMaxPlayers = (gameFormat) => {
            const formatArray = FORMATIONS[gameFormat];
            // Since all formations for a format must have the same number of outfield players, grab the first one
            return formatArray && formatArray.length > 0 ? formatArray[0].maxPlayers : 0;
        };


        const calculateEqualMinutes = (settings, players) => {
          const { gameFormat, matchDuration, isPermanentGK } = settings;
          if (!matchDuration || matchDuration <= 0 || players.length === 0) return players;
          
          const outfieldSpots = getOutfieldMaxPlayers(gameFormat);
          const outfieldPlayers = players.filter(p => p.role !== 'GK');
          const numOutfieldPlayers = outfieldPlayers.length;
          if (numOutfieldPlayers === 0) return players;

          const totalOutfieldMinutesAvailable = outfieldSpots * matchDuration;
          const baseEqualTime = Math.floor(totalOutfieldMinutesAvailable / numOutfieldPlayers);
          let remainderMinutes = totalOutfieldMinutesAvailable % numOutfieldPlayers;

          const updatedPlayers = players.map((player) => {
            if (player.role === 'GK') {
              return { ...player, minutes: isPermanentGK ? matchDuration : 0 };
            }

            let finalMinutes = baseEqualTime;
            if (remainderMinutes > 0) {
              finalMinutes += 1;
              remainderMinutes--;
            }

            const effectiveMinutes = player.manualMinutes !== null ? player.manualMinutes : finalMinutes;
            return { ...player, minutes: effectiveMinutes };
          });

          return updatedPlayers;
        };

        const generateAutomaticPlan = (settings, playersWithMinutes) => {
          const { gameFormat, matchDuration, selectedFormation, subInterval, firstSubTime, maxSubs, matchPeriods } = settings;
          const positions = getOutfieldSlots(gameFormat, selectedFormation);
          const outfieldSpots = positions.length;

          const periods = gameFormat === '5v5' && matchPeriods === 'Quarters' ? 4 : 2;
          const halfDuration = matchDuration / 2;
          const periodDuration = matchDuration / periods;

          let outfieldPlayers = playersWithMinutes
            .filter(p => p.role !== 'GK' && p.minutes > 0)
            .sort((a, b) => a.minutes - b.minutes);

          const gkPlayer = playersWithMinutes.find(p => p.role === 'GK');
          const allPlayers = playersWithMinutes;

          if (outfieldPlayers.length <= outfieldSpots) {
            return {
                planText: `--- Match Info ---\nFormat: ${gameFormat} (${matchPeriods})\nDuration: ${matchDuration} min (${periods} x ${periodDuration} min periods)\n\nAll participating players can play the full match duration based on the squad size and game format. No substitutions required for minutes management.`,
                lineups: [{ time: '0:00 (Start)', players: allPlayers.map(p => ({ ...p, position: p.startingPosition || 'Bench' })) }]
            };
          }

          let plan = `--- Match Info ---\nFormat: ${gameFormat} (${matchPeriods})\nDuration: ${matchDuration} min (Half: ${halfDuration} min)\n\n`;
          plan += `GK: ${gkPlayer ? gkPlayer.name : 'Unassigned GK'}\n`;
          plan += `Formation: ${selectedFormation} (${outfieldSpots} outfield slots)\n\n`;
          
          let playing = [];
          let bench = [];
          let rotationQueue = [...outfieldPlayers];
          let subCount = 0;
          let lineups = []; 

          // 1. Assign starters and bench for the FIRST HALF
          // Use the StartingPosition if available, otherwise rely on minute priority
          const startersWithPositions = players.filter(p => p.startingPosition);
          const customStarters = startersWithPositions.filter(p => p.startingPosition !== 'GK').slice(0, outfieldSpots);
          
          if (customStarters.length === outfieldSpots) {
              playing = customStarters;
              rotationQueue = outfieldPlayers.filter(p => !customStarters.map(s => s.id).includes(p.id));
              bench = rotationQueue;
          } else {
              // Fallback to minutes priority for starting lineup
              for (let i = 0; i < outfieldSpots; i++) {
                  playing.push(rotationQueue.shift()); 
              }
              bench = rotationQueue;
          }

          // Record starting lineup
          lineups.push({ 
              time: '0:00 (Start)', 
              players: allPlayers.map(p => ({ 
                  ...p, 
                  position: p.role === 'GK' ? 'GK' : (playing.find(pl => pl.id === p.id) ? positions[playing.findIndex(pl => pl.id === p.id)] : 'Bench') 
              }))
          });
          
          let currentPeriodMinutes = new Map(outfieldPlayers.map(p => [p.id, 0]));

          plan += `--- STARTING LINEUP (0:00) ---\n`;
          playing.forEach((p, i) => {
            plan += `${positions[i]}: ${p.name} (Target Mins/Half: ${Math.ceil(p.minutes / periods * 2)})\n`; 
          });
          plan += `\n`;

          for (let period = 1; period <= periods; period++) {
            const periodStart = (period - 1) * periodDuration;
            const periodEnd = period * periodDuration;
            let time = periodStart + firstSubTime;
            let lastSubTime = periodStart;
            
            if (period > 1) {
                const periodName = periods === 4 ? `QUARTER ${period}` : `SECOND HALF`;
                plan += `\n*** ${periodName} START (${periodStart}:00) - ROTATION RESET FOR EVEN MINUTES ***\n\n`;

                const allPlayersInRotation = [...playing, ...bench];
                
                let newPlaying = allPlayersInRotation.filter(p => bench.map(b => b.id).includes(p.id)).slice(0, outfieldSpots);
                let newBench = allPlayersInRotation.filter(p => !newPlaying.map(np => np.id).includes(p.id));

                playing = newPlaying;
                bench = newBench;
                
                currentPeriodMinutes.forEach((v, k) => currentPeriodMinutes.set(k, 0));
                
                plan += `--- STARTING LINEUP (${periodStart}:00) ---\n`;
                playing.forEach((p, i) => {
                    plan += `${positions[i]}: ${p.name}\n`;
                });
                plan += `\n`;

                // Record Half/Quarter Start Lineup
                lineups.push({ 
                    time: `${periodStart}:00 (${periodName})`, 
                    players: allPlayers.map(p => ({ 
                        ...p, 
                        position: p.role === 'GK' ? 'GK' : (playing.find(pl => pl.id === p.id) ? positions[playing.findIndex(pl => pl.id === p.id)] : 'Bench') 
                    }))
                });
                
                time = periodStart + firstSubTime;
                lastSubTime = periodStart;
            }


            while (time <= periodEnd) {
              if (bench.length === 0) break;

              const elapsed = time - lastSubTime;
              const outgoingCandidates = [];

              playing.forEach((player, index) => {
                  currentPeriodMinutes.set(player.id, currentPeriodMinutes.get(player.id) + elapsed);
                  outgoingCandidates.push({ 
                      player, 
                      position: positions[index], 
                      index,
                      periodTimePlayed: currentPeriodMinutes.get(player.id)
                  });
              });
              
              outgoingCandidates.sort((a, b) => b.periodTimePlayed - a.periodTimePlayed);
              
              const subsForThisWindow = Math.min(maxSubs, bench.length, outgoingCandidates.length);
              const subsBlock = [];
              
              const playersToSubOut = outgoingCandidates.slice(0, subsForThisWindow);
              let incomingCandidates = [...bench].sort((a, b) => a.minutes - b.minutes);
              
              playersToSubOut.forEach((outgoing) => {
                  const position = outgoing.position;
                  const incoming = incomingCandidates.shift();
                  if (!incoming) return;

                  playing[outgoing.index] = incoming;
                  
                  subsBlock.push({
                      on: incoming,
                      off: outgoing.player,
                      position: position,
                      index: outgoing.index
                  });
                  
                  bench = bench.filter(p => p.id !== incoming.id);
                  bench.push(outgoing.player);
              });

              if (subsBlock.length > 0) {
                  subCount += subsBlock.length;
                  plan += `--- Substitution at ${String(time).padStart(2, '0')}:00 ---\n`;
                  subsBlock.forEach(sub => {
                      plan += `ON: ${sub.on.name} (${sub.position} slot) | OFF: ${sub.off.name}\n`;
                  });
                  plan += `\n`;
                
                // Record the substitution lineup
                lineups.push({ 
                    time: `${String(time).padStart(2, '0')}:00 (Sub)`, 
                    players: allPlayers.map(p => ({ 
                        ...p, 
                        position: p.role === 'GK' ? 'GK' : (playing.find(pl => pl.id === p.id) ? positions[playing.findIndex(pl => pl.id === p.id)] : 'Bench') 
                    }))
                });
              }
              
              lastSubTime = time;
              time += subInterval;

              if (time > periodEnd) break;
            }
          }

          plan += `--- Match End (${matchDuration}:00) ---\n`;
          plan += `Total substitutions made: ${subCount}. \n\n`;
          plan += '***Note: This automatic plan ensures equal minutes across the two halves by resetting the playing/bench queues at halftime. The positions are fixed based on the starting formation.***';

          return { planText: plan, lineups };
        };


        // --- UI COMPONENTS ---

        const PlayerInputRow = ({ player, index, settings, setPlayers, subscriptionTier, allPositions }) => {
          const isChampionship = subscriptionTier !== 'Basic';
          const isPremiership = subscriptionTier === 'Premiership';
          const availablePositions = ALL_POSITIONS.filter(p => p !== 'GK' || index === 0);

          const handleChange = (field, value) => {
            setPlayers(prev => prev.map(p => {
                if (p.id !== player.id) return p;

                let updated = { ...p, [field]: value };

                // Logic for Starting Position -> Preferred Position auto-mirror
                if (field === 'startingPosition' && value !== '') {
                    updated.preferredPosition = value;
                }
                
                // Logic for GK role management
                if (updated.preferredPosition === 'GK') {
                    updated.role = 'GK';
                } else if (p.role === 'GK' && index !== 0) {
                     updated.role = 'Outfield';
                } else if (p.role === 'GK' && index === 0 && updated.preferredPosition !== 'GK') {
                     updated.role = 'Outfield';
                }

                return updated;
            }));
          };
            
          return (
            <div className="flex items-center space-x-2 py-2 border-b border-gray-100">
              <span className="text-xs font-semibold w-6 text-center text-gray-500">{index + 1}</span>
              <input
                type="text"
                placeholder={`Player Name ${index + 1}`}
                value={player.name}
                onChange={(e) => handleChange('name', e.target.value)}
                className="flex-grow p-2 border rounded-lg focus:ring-sky-blue focus:border-sky-blue transition duration-150"
              />
                {/* NEW: Starting Position (mirrors to Preferred Position) */}
                <select
                    value={player.startingPosition || ''}
                    onChange={(e) => handleChange('startingPosition', e.target.value)}
                    className="p-2 border rounded-lg w-28 text-sm bg-white"
                >
                    <option value="">Start Pos.</option>
                    {availablePositions.map(pos => <option key={`start-${pos}`} value={pos}>{pos}</option>)}
                </select>

                {/* Preferred Position (manual override allowed) */}
              <select
                value={player.preferredPosition}
                onChange={(e) => handleChange('preferredPosition', e.target.value)}
                className="p-2 border rounded-lg w-28 text-sm bg-white"
              >
                <option value="">Pref. Pos.</option>
                {availablePositions.map(pos => <option key={`pref-${pos}`} value={pos}>{pos}</option>)}
              </select>

              {isChampionship && (
                <select
                  value={player.secondaryPosition}
                  onChange={(e) => handleChange('secondaryPosition', e.target.value)}
                  className={`p-2 border rounded-lg w-28 text-sm bg-white`}
                >
                  <option value="">Sec. Pos.</option>
                  {availablePositions.map(pos => <option key={`sec-${pos}`} value={pos}>{pos}</option>)}
                </select>
              )}

              {isPremiership && (
                <input
                  type="number"
                  placeholder="Manual Mins"
                  value={player.manualMinutes === null ? '' : player.manualMinutes}
                  onChange={(e) => handleChange('manualMinutes', e.target.value === '' ? null : parseInt(e.target.value, 10))}
                  className={`p-2 border rounded-lg w-24 text-sm text-center`}
                />
              )}
            </div>
          );
        };

        const PlayerCircle = ({ name, position, isGK, color = COLORS.SKY_BLUE, yPos, xPos }) => {
            // Displays position code inside the circle
            const displayPos = position.length > 4 ? position.replace('-', '/') : position;
            const firstName = name.split(' ')[0];
            
            return (
          <div
            className="absolute flex flex-col items-center justify-center transition-all duration-500 ease-in-out"
            style={{ top: `${yPos}%`, left: `${xPos}%`, transform: 'translate(-50%, -50%)', zIndex: Math.round(yPos) }}
            title={`${name} (${position})`}
          >
            <div
              className="w-12 h-12 rounded-full flex items-center justify-center text-xs font-bold text-white shadow-lg border-2"
              style={{
                backgroundColor: color,
                borderColor: isGK ? COLORS.ORANGE : color,
              }}
            >
              {displayPos || 'POS'}
            </div>
            <span className={`text-xs mt-1 font-medium text-center`} style={{ color: COLORS.NAVY_BLUE }}>{firstName}</span>
          </div>
        )};


        const PositionVisualizer = ({ settings, lineups, currentLineupIndex, isPremiership }) => {
          const { gameFormat, selectedFormation } = settings;

          const displayLineup = lineups[currentLineupIndex] || { players: [], time: 'N/A' };
          
          const playersOnField = displayLineup.players.filter(p => p.position !== 'Bench' && p.name.trim() !== '');

          const getPositionCoordinates = (position) => {
            const map = {
                GK: { y: 95, x: 50 },
                RB: { y: 80, x: 15 }, LB: { y: 80, x: 85 },
                CD: { y: 85, x: 50 }, 'CD-R': { y: 85, x: 30 }, 'CD-L': { y: 85, x: 70 },
                CDM: { y: 70, x: 50 }, 'CDM-R': { y: 70, x: 25 }, 'CDM-L': { y: 70, x: 75 },
                CM: { y: 50, x: 50 }, 'CM-R': { y: 50, x: 20 }, 'CM-L': { y: 50, x: 80 },
                CAM: { y: 35, x: 50 },
                RW: { y: 20, x: 10 }, LW: { y: 20, x: 90 },
                ST: { y: 15, x: 50 }, 'ST-R': { y: 18, x: 30 }, 'ST-L': { y: 18, x: 70 },
            };
            return map[position] || { y: 50, x: 50 };
          };

          const visualPlayers = playersOnField.map((player) => {
            const { y, x } = getPositionCoordinates(player.position);
            const isGK = player.position === 'GK';
            const color = isGK ? COLORS.NAVY_BLUE : COLORS.SKY_BLUE;
            return <PlayerCircle key={player.id} name={player.name} position={player.position} isGK={isGK} color={color} yPos={y} xPos={x} />;
          });


          if (!isPremiership && currentLineupIndex > 0 && lineups.length > 1) {
            return (
                <div className="flex items-center justify-center w-full h-96 border-4 border-dashed rounded-xl" style={{ borderColor: COLORS.GOLD, color: COLORS.GOLD }}>
                    <div className="text-center p-4">
                        <Star className="w-10 h-10 mx-auto fill-current mb-2" />
                        <p className="font-bold text-lg">Visual Timeline (Premiership Only)</p>
                        <p className="text-sm mt-1">Upgrade to view and step through the full match substitution sequence.</p>
                    </div>
                </div>
            )
          }

          return (
            <div className="relative w-full h-96 border-4 border-green-800 bg-green-700/80 rounded-xl overflow-hidden shadow-inner">
              <div className="absolute inset-0 border-white border-2 m-4 rounded-lg opacity-80">
                <div className="absolute top-1/2 left-1/2 w-20 h-20 border-white border-2 rounded-full transform -translate-x-1/2 -translate-y-1/2 opacity-80"></div>
                <div className="absolute top-0 left-1/2 w-40 h-10 border-white border-2 transform -translate-x-1/2"></div>
                <div className="absolute bottom-0 left-1/2 w-40 h-10 border-white border-2 transform -translate-x-1/2 -scale-y-100"></div>
              </div>

              {visualPlayers}

              <div className="absolute bottom-2 right-2 text-xs font-semibold text-white bg-black/50 p-1 rounded">
                {settings.gameFormat} - {selectedFormation} ({displayLineup.time})
              </div>
            </div>
          );
        };
        
        const SubscriptionBadge = ({ tier }) => {
          let color, icon, text;

          if (tier === 'Premiership') {
            color = COLORS.GOLD;
            icon = <Star className="w-4 h-4 text-white fill-current mr-1" />;
            text = 'Premiership';
          } else if (tier === 'Championship') {
            color = COLORS.SKY_BLUE;
            icon = <Unlock className="w-4 h-4 text-white mr-1" />;
            text = 'Championship';
          } else {
            color = COLORS.NAVY_BLUE;
            icon = null;
            text = 'Basic (FREE)';
          }

          return (
            <div
              className="px-3 py-1 rounded-full text-xs font-bold flex items-center shadow-md"
              style={{ backgroundColor: color, color: COLORS.WHITE }}
            >
              {icon}
              {text}
            </div>
          );
        };

        const Button = ({ children, color = COLORS.ORANGE, disabled, onClick }) => (
          <button
            onClick={onClick}
            disabled={disabled}
            className={`flex items-center justify-center px-6 py-3 rounded-xl font-bold text-white shadow-lg transition duration-200 ${
              disabled
                ? 'opacity-50 cursor-not-allowed bg-gray-400'
                : 'hover:opacity-90 active:scale-[0.98]'
            }`}
            style={{ backgroundColor: color }}
          >
            {children}
          </button>
        );

        const SubstitutionTimeline = ({ lineups, currentLineupIndex, setCurrentLineupIndex }) => {
            if (lineups.length <= 1) return null;

            const maxIndex = lineups.length - 1;

            return (
                <div className="mt-4 flex items-center space-x-2 p-2 bg-gray-100 rounded-lg border-t border-b" style={{ borderColor: COLORS.SKY_BLUE }}>
                    <span className="font-semibold text-sm" style={{ color: COLORS.NAVY_BLUE }}>View Lineup:</span>
                    <button 
                        onClick={() => setCurrentLineupIndex(Math.max(0, currentLineupIndex - 1))}
                        disabled={currentLineupIndex === 0}
                        className="p-1 px-3 text-sm bg-gray-300 rounded disabled:opacity-50"
                    >
                        &lt; Previous
                    </button>
                    <div className="flex-grow text-center font-mono text-sm font-bold" style={{ color: COLORS.ORANGE }}>
                        {lineups[currentLineupIndex].time} (Event {currentLineupIndex + 1} of {lineups.length})
                    </div>
                    <button 
                        onClick={() => setCurrentLineupIndex(Math.min(maxIndex, currentLineupIndex + 1))}
                        disabled={currentLineupIndex === maxIndex}
                        className="p-1 px-3 text-sm bg-gray-300 rounded disabled:opacity-50"
                    >
                        Next &gt;
                    </button>
                </div>
            );
        };


        // --- MAIN APPLICATION COMPONENT ---

        const App = () => {
          const { db, userId, isAuthReady, firestorePath, error } = useFirebase();

          const [subscriptionTier, setSubscriptionTier] = useState('Premiership');

          const [settings, setSettings] = useState(() => {
            const defaultFormat = '9v9';
            return {
              gameFormat: defaultFormat,
              matchDuration: MATCH_DURATIONS[defaultFormat],
              squadSize: 11,
              isPermanentGK: true,
              selectedFormation: '3-3-2',
              planType: 'Automatic', 
              subInterval: 10,
              firstSubTime: 10,
              maxSubs: 2,
              matchPeriods: 'Halves', 
            };
          });
          
          const [players, setPlayers] = useState(
            Array.from({ length: 20 }, (_, i) => ({
              id: generateUUID(),
              name: i === 0 ? 'Ella (GK)' : i === 1 ? 'Mia' : i < 11 ? `Player ${i + 1}` : '',
              role: i === 0 ? 'GK' : 'Outfield',
              startingPosition: i === 0 ? 'GK' : '', 
              preferredPosition: i === 0 ? 'GK' : '',
              secondaryPosition: '',
              manualMinutes: null,
            }))
          );

          const [matchPlan, setMatchPlan] = useState('');
          const [matchLineups, setMatchLineups] = useState([]);
          const [currentLineupIndex, setCurrentLineupIndex] = useState(0);

          const [isGenerating, setIsGenerating] = useState(false);
          const [savedSquads, setSavedSquads] = useState([]);
          const [isSavingLoading, setIsSavingLoading] = useState(false);


          const maxSquads = subscriptionTier === 'Championship' ? 2 : Infinity;
          const isChampionship = subscriptionTier !== 'Basic';
          const isPremiership = subscriptionTier === 'Premiership';
          const outfieldSpots = getOutfieldMaxPlayers(settings.gameFormat);
          const formationsAvailable = FORMATIONS[settings.gameFormat];

          const activePlayers = useMemo(() => players.filter(p => p.name.trim() !== ''), [players]);

          const displayedPlayers = useMemo(() => players.slice(0, settings.squadSize), [players, settings.squadSize]);

          useEffect(() => {
            const duration = MATCH_DURATIONS[settings.gameFormat];
            // Find the default formation name based on the old structure of setting the first key
            const defaultFormation = formationsAvailable && formationsAvailable.length > 0 ? formationsAvailable[0].name : '';
            
            setSettings(prev => ({ 
              ...prev, 
              matchDuration: duration,
              selectedFormation: defaultFormation,
              matchPeriods: settings.gameFormat === '5v5' ? prev.matchPeriods : 'Halves', 
            }));
          }, [settings.gameFormat]);

          const fetchSquads = useCallback(async () => {
            if (!isAuthReady || !db || !firestorePath) return;

            setIsSavingLoading(true);
            try {
              const collectionRef = db.collection(firestorePath);
              const q = db.query(collectionRef);
              
              const docs = await retryFetch(() => db.getDocs(q));

              const squads = docs.docs.map(d => ({
                id: d.id,
                name: d.data().name,
                data: d.data().players,
              }));
              setSavedSquads(squads);

            } catch (e) {
              console.error('Error fetching squads:', e);
            } finally {
              setIsSavingLoading(false);
            }
          }, [db, firestorePath, isAuthReady]);

          useEffect(() => {
            if (isChampionship) {
              fetchSquads();
            }
          }, [isChampionship, fetchSquads]);


          const handleSaveSquad = async () => {
            if (!isChampionship || (!isPremiership && savedSquads.length >= maxSquads)) {
              console.error('Cannot save: Subscription limits reached.');
              return;
            }

            const squadName = `Squad ${new Date().toLocaleTimeString()} (${settings.gameFormat})`;

            if (!squadName) return;

            setIsSavingLoading(true);
            try {
              const squadData = {
                name: squadName,
                players: displayedPlayers.filter(p => p.name.trim() !== ''),
                createdAt: new Date().toISOString(),
              };
              
              const collectionRef = db.collection(firestorePath);
              const newDocRef = db.doc(collectionRef);
              await retryFetch(() => db.setDoc(newDocRef, squadData));
              
              console.log('Squad saved successfully.');
              fetchSquads();
            } catch (e) {
              console.error('Error saving squad:', e);
            } finally {
              setIsSavingLoading(false);
            }
          };

          const handleLoadSquad = (squadData) => {
            const loadedPlayers = squadData.map((p, i) => ({ ...p, id: p.id || generateUUID() }));
            setSettings(prev => ({ ...prev, squadSize: loadedPlayers.length }));

            const newPlayers = Array.from({ length: 20 }, (_, i) => {
              if (i < loadedPlayers.length) {
                return loadedPlayers[i];
              }
              return { id: generateUUID(), name: '', role: 'Outfield', startingPosition: '', preferredPosition: '', secondaryPosition: '', manualMinutes: null };
            });
            setPlayers(newPlayers);
            setMatchPlan('');
          setMatchLineups([]);
          setCurrentLineupIndex(0);
            console.log('Squad loaded.');
          };

          const handleDeleteSquad = async (id) => {
            console.log(`Squad deletion requested for ID: ${id}`);
            
            setIsSavingLoading(true);
            try {
              const collectionRef = db.collection(firestorePath);
              const docRef = db.doc(collectionRef, id);
              await retryFetch(() => db.deleteDoc(docRef));
              console.log('Squad deleted successfully.');
              fetchSquads();
            } catch (e) {
              console.error('Error deleting squad:', e);
            } finally {
              setIsSavingLoading(false);
            }
          };


          const handleGeneratePlan = () => {
            if (activePlayers.length < outfieldSpots + 1) {
              setMatchPlan('Error: Not enough players to fill the formation spots.');
              setMatchLineups([]);
              return;
            }
            if (!settings.matchDuration || settings.matchDuration <= 0) {
              setMatchPlan('Error: Match duration must be greater than zero.');
              setMatchLineups([]);
              return;
            }

            setIsGenerating(true);
            setMatchPlan('');
          setMatchLineups([]);
          setCurrentLineupIndex(0);

            setTimeout(() => {
              try {
                const playersWithCalculatedMinutes = calculateEqualMinutes(settings, displayedPlayers);

                let planResult;
                if (settings.planType === 'Automatic') {
                  planResult = generateAutomaticPlan(settings, playersWithCalculatedMinutes);
                } else {
                  // Manual Plan Placeholder (Still generates a starting lineup visual)
                  const gkPlayer = playersWithCalculatedMinutes.find(p => p.role === 'GK');
                  const outfieldStarters = playersWithCalculatedMinutes.filter(p => p.role !== 'GK').slice(0, outfieldSpots);
                  const positions = getOutfieldSlots(settings.gameFormat, settings.selectedFormation);

                  const startingLineupPlayers = playersWithCalculatedMinutes.map(p => ({
                      ...p,
                      position: p.role === 'GK' ? 'GK' : (outfieldStarters.find(pl => pl.id === p.id) ? positions[outfieldStarters.findIndex(pl => pl.id === p.id)] : 'Bench')
                  }));

                  let planText = `--- Manual Plan Creation (Premiership Only) ---\n\n`;
                  planText += `To create a manual plan, you would use interactive controls here to define which player subs on and off at which minute. The plan below shows the starters.\n\n`;
                  planText += `GK: ${gkPlayer ? gkPlayer.name : 'Unassigned GK'}\n`;
                  positions.forEach((pos, i) => {
                    planText += `${pos}: ${outfieldStarters[i]?.name || 'N/A'}\n`;
                  });

                  planResult = { planText, lineups: [{ time: '0:00 (Start)', players: startingLineupPlayers }] };
                }

                let finalPlanText = planResult.planText;
                
                // --- Minutes Summary ---
                const minutesSummary = playersWithCalculatedMinutes
                    .filter(p => p.name.trim() !== '')
                    .sort((a, b) => {
                        if (a.role === 'GK' && b.role !== 'GK') return -1;
                        if (a.role !== 'GK' && b.role === 'GK') return 1;
                        return a.name.localeCompare(b.name);
                    })
                    .map(p => `${p.name} (${p.role}): ${p.minutes} mins${p.manualMinutes !== null ? ' (Manual)' : ''}`)
                    .join('\n');
                
                finalPlanText += `\n\n--- PLAYER MINUTES SUMMARY ---\n\n`;
                finalPlanText += minutesSummary;
                finalPlanText += `\n\n------------------------------\n\n`;


                setMatchPlan(finalPlanText);
              setMatchLineups(planResult.lineups);
              } catch (e) {
                setMatchPlan(`An error occurred during plan generation: ${e.message}`);
                console.error('Generation Error:', e);
              } finally {
                setIsGenerating(false);
              }
            }, 500);
          };

          // --- Render ---

          if (error) {
            return <div className="text-red-600 p-4 bg-red-100 rounded-lg m-4">Initialization Error: {error}</div>;
          }
          
          if (!isAuthReady) {
            return (
              <div className="flex justify-center items-center h-screen" style={{ backgroundColor: '#F0F4F8' }}>
                <Loader2 className="w-8 h-8 animate-spin" style={{ color: COLORS.NAVY_BLUE }} />
                <span className="ml-2 font-semibold" style={{ color: COLORS.NAVY_BLUE }}>Authenticating and Initializing...</span>
              </div>
            );
          }

          return (
            <div className="p-4 md:p-8 min-h-screen" style={{ backgroundColor: COLORS.WHITE, fontFamily: 'Inter, sans-serif' }}>
              <header className="flex flex-col md:flex-row justify-between items-center pb-6 border-b-4 mb-6" style={{ borderColor: COLORS.NAVY_BLUE }}>
                <div className="flex items-center space-x-4">
                  <img
                    src="https://placehold.co/100x100/193755/AF9542?text=TGGPLOGO" 
                    alt="The Girls' Game Plan Logo" 
                    className="w-16 h-16 rounded-full shadow-lg"
                  />
                  <h1 className="text-4xl font-extrabold" style={{ color: COLORS.NAVY_BLUE }}>
                    The Girls' Game Planner
                  </h1> 
                </div>
                <SubscriptionBadge tier={subscriptionTier} />
              </header>

              <p className="text-sm font-medium mb-6 p-3 rounded-lg" style={{ backgroundColor: COLORS.SKY_BLUE, color: COLORS.NAVY_BLUE }}>
                <User className="inline w-4 h-4 mr-1 align-sub" /> User ID: <span className="font-mono text-xs">{userId}</span>
              </p>

              <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-1 space-y-6">
                  <div className="p-6 rounded-xl shadow-2xl" style={{ backgroundColor: COLORS.NAVY_BLUE, color: COLORS.WHITE }}>
                    <h2 className="text-2xl font-bold mb-4 flex items-center"><Settings className="w-6 h-6 mr-2" /> Match Setup</h2>

                    <div className="space-y-4">
                      <label className="block">Game Format (XvX)</label>
                      <select
                        value={settings.gameFormat}
                        onChange={(e) => setSettings(p => ({ ...p, gameFormat: e.target.value }))}
                        className="w-full p-2 rounded-lg text-lg font-semibold" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
                      >
                        {Object.keys(FORMATIONS).map(f => <option key={f} value={f}>{f}</option>)}
                      </select>

                      <label className="block pt-2">Match Duration (min)</label>
                      <input
                        type="number"
                        value={settings.matchDuration}
                        readOnly
                        disabled
                        className="w-full p-2 rounded-lg text-lg font-semibold bg-gray-200 cursor-not-allowed" style={{ color: COLORS.NAVY_BLUE }}
                      />
                      <p className="text-xs text-white/70 mt-1">Duration is set automatically based on FA guidelines for {settings.gameFormat}.</p>

                      {settings.gameFormat === '5v5' && (
                        <div className="pt-2">
                          <label className="block">5v5 Match Periods</label>
                          <div className="flex space-x-4">
                            <label className="flex items-center">
                              <input
                                type="radio"
                                checked={settings.matchPeriods === 'Halves'}
                                onChange={() => setSettings(p => ({ ...p, matchPeriods: 'Halves' }))}
                                className="mr-2"
                              /> Halves (2 x 20 min)
                            </label>
                            <label className="flex items-center">
                              <input
                                type="radio"
                                checked={settings.matchPeriods === 'Quarters'}
                                onChange={() => setSettings(p => ({ ...p, matchPeriods: 'Quarters' }))}
                                className="mr-2"
                              /> Quarters (4 x 10 min)
                            </label>
                          </div>
                        </div>
                      )}

                      <label className="block pt-2">Squad Size</label>
                      <input
                        type="number"
                        min={outfieldSpots + (settings.isPermanentGK ? 1 : 0)}
                        value={settings.squadSize}
                        onChange={(e) => {
                          const val = e.target.value;
                          const parsedVal = val === '' ? 0 : parseInt(val, 10);
                          setSettings(p => ({ ...p, squadSize: parsedVal }));
                        }}
                        className="w-full p-2 rounded-lg text-lg font-semibold" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
                      />

                      <label className="block pt-2">Goalkeeper Rotation</label>
                      <div className="flex space-x-4">
                        <label className="flex items-center">
                          <input
                            type="radio"
                            checked={settings.isPermanentGK}
                            onChange={() => setSettings(p => ({ ...p, isPermanentGK: true, gkRotation: false }))}
                            className="mr-2"
                          /> Permanent GK
                        </label>
                        <label className="flex items-center">
                          <input
                            type="radio"
                            checked={!settings.isPermanentGK}
                            onChange={() => setSettings(p => ({ ...p, isPermanentGK: false, gkRotation: true }))}
                            className="mr-2"
                          /> Rotating GK
                        </label>
                      </div>

                      <label className="block pt-2">Formation (Outfield Players)</label>
                      <select
                        value={settings.selectedFormation}
                        onChange={(e) => setSettings(p => ({ ...p, selectedFormation: e.target.value }))}
                        className="w-full p-2 rounded-lg text-lg font-semibold" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
                      >
                        {formationsAvailable.map(f => <option key={f.name} value={f.name}>{f.name}</option>)}
                      </select>
                    </div>
                  </div>

                  {isChampionship && (
                    <div className="p-6 rounded-xl shadow-lg border" style={{ borderColor: COLORS.NAVY_BLUE }}>
                      <h3 className="text-xl font-bold mb-4 flex items-center" style={{ color: COLORS.NAVY_BLUE }}>
                        <Save className="w-5 h-5 mr-2" style={{ color: COLORS.NAVY_BLUE }} /> Squad Management
                      </h3>
                      <p className="text-sm mb-4" style={{ color: COLORS.NAVY_BLUE }}>
                        {isPremiership ? 'Unlimited Squad Saves' : `Save up to ${maxSquads} Squads`} (Current: {savedSquads.length})
                      </p>

                      <Button onClick={handleSaveSquad} disabled={isSavingLoading || (!isPremiership && savedSquads.length >= maxSquads)} color={COLORS.SKY_BLUE}>
                        {isSavingLoading ? <Loader2 className="w-5 h-5 animate-spin mr-2" /> : 'Save Current Squad'}
                      </Button>

                      <div className="mt-4 space-y-2 max-h-48 overflow-y-auto custom-scrollbar">
                        {savedSquads.map(squad => (
                          <div key={squad.id} className="flex justify-between items-center p-2 rounded-lg border" style={{ borderColor: COLORS.SKY_BLUE }}>
                            <span className="text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>{squad.name} ({squad.data.length} players)</span>
                            <div className="flex space-x-1">
                              <button onClick={() => handleLoadSquad(squad.data)} className="text-xs px-2 py-1 rounded-full text-white" style={{ backgroundColor: COLORS.ORANGE }}>Load</button>
                              <button onClick={() => handleDeleteSquad(squad.id)} className="text-xs px-2 py-1 rounded-full text-white bg-red-500">Del</button>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>

                <div className="lg:col-span-2 space-y-6">
                  <div className="p-6 rounded-xl shadow-2xl bg-white">
                    <h2 className="text-2xl font-bold mb-4 flex items-center" style={{ color: COLORS.NAVY_BLUE }}><User className="w-6 h-6 mr-2" /> Player Roster</h2>
                    <div className="max-h-96 overflow-y-auto custom-scrollbar">
                      {displayedPlayers.map((player, index) => (
                        <PlayerInputRow
                          key={player.id}
                          player={player}
                          index={index}
                          settings={settings}
                          setPlayers={setPlayers}
                          subscriptionTier={subscriptionTier}
                          allPositions={ALL_POSITIONS}
                        />
                      ))}
                    </div>
                  </div>

                  <div className="p-6 rounded-xl shadow-lg bg-white border" style={{ borderColor: COLORS.SKY_BLUE }}>
                    <h3 className="text-xl font-bold mb-4" style={{ color: COLORS.NAVY_BLUE }}>Plan Options</h3>
                    
                    <div className="flex space-x-4 mb-6">
                        <div className={`p-4 rounded-lg flex-1 shadow-md border ${settings.planType === 'Automatic' ? 'border-2' : 'border'}`} style={{ borderColor: settings.planType === 'Automatic' ? COLORS.ORANGE : COLORS.NAVY_BLUE }}>
                            <label className="flex items-center font-bold w-full" style={{ color: COLORS.NAVY_BLUE }}>
                                <input
                                type="radio"
                                checked={settings.planType === 'Automatic'}
                                onChange={() => setSettings(p => ({ ...p, planType: 'Automatic' }))}
                                className="mr-3"
                                /> 
                                Automatic (Equal Minutes)
                            </label>
                        </div>

                        <div className={`p-4 rounded-lg flex-1 shadow-md border ${isPremiership ? '' : 'opacity-50 cursor-not-allowed'}`} style={{ borderColor: settings.planType === 'Manual' ? COLORS.ORANGE : COLORS.NAVY_BLUE }}>
                            <label className={`flex items-center font-bold w-full`} style={{ color: COLORS.NAVY_BLUE }}>
                                <input
                                type="radio"
                                checked={settings.planType === 'Manual'}
                                onChange={() => isPremiership && setSettings(p => ({ ...p, planType: 'Manual' }))}
                                className="mr-3"
                                disabled={!isPremiership}
                                /> 
                                Manual Plan {isPremiership ? '' : '(Premiership Only)'}
                            </label>
                        </div>
                    </div>

                    {settings.planType === 'Automatic' && (
                      <div className={`grid grid-cols-3 gap-4 p-4 rounded-lg border-dashed border ${isPremiership ? '' : 'opacity-50 pointer-events-none bg-gray-50'}`} style={{ borderColor: COLORS.NAVY_BLUE }}>
                        <p className={`col-span-3 text-sm font-semibold mb-2 ${isPremiership ? 'text-gray-700' : 'text-orange-500'}`}>
                          {isPremiership ? 'Substitution Frequency (Premiership)' : 'Upgrade to Premiership for Sub Control'}
                        </p>
                        <div>
                          <label className="block text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>Interval (min)</label>
                          <select
                            value={settings.subInterval}
                            onChange={(e) => setSettings(p => ({ ...p, subInterval: parseInt(e.target.value, 10) }))}
                            className="w-full p-2 rounded-lg text-sm" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
                            disabled={!isPremiership}
                          >
                            {[5, 8, 10, 15].map(v => <option key={v} value={v}>{v}</option>)}
                          </select>
                        </div>
                        <div>
                          <label className="block text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>First Sub (min)</label>
                          <select
                            value={settings.firstSubTime}
                            onChange={(e) => setSettings(p => ({ ...p, firstSubTime: parseInt(e.target.value, 10) }))}
                            className="w-full p-2 rounded-lg text-sm" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
                            disabled={!isPremiership}
                          >
                            {[5, 8, 10, 15].map(v => <option key={v} value={v}>{v}</option>)}
                          </select>
                        </div>
                        <div>
                          <label className="block text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>Max Subs (#)</label>
                          <select
                            value={settings.maxSubs}
                            onChange={(e) => setSettings(p => ({ ...p, maxSubs: parseInt(e.target.value, 10) }))}
                            className="w-full p-2 rounded-lg text-sm" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
                            disabled={!isPremiership}
                          >
                            {[1, 2, 3, 4].map(v => <option key={v} value={v}>{v}</option>)}
                          </select>
                        </div>
                      </div>
                    )}
                    
                    <Button onClick={handleGeneratePlan} disabled={isGenerating} color={COLORS.ORANGE} className="mt-6 w-full">
                      {isGenerating ? <Loader2 className="w-5 h-5 animate-spin mr-2" /> : <Play className="w-5 h-5 mr-2" />}
                      {isGenerating ? 'Generating...' : 'Generate Match Plan'}
                    </Button>
                  </div>
                </div>
              </div>

              <div className="mt-8">
                <h2 className="text-3xl font-bold mb-4" style={{ color: COLORS.NAVY_BLUE }}>Match Plan Output</h2>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                  <div className="p-6 rounded-xl shadow-xl bg-gray-50">
                    <h3 className="text-xl font-bold mb-4 border-b pb-2" style={{ color: COLORS.NAVY_BLUE, borderColor: COLORS.SKY_BLUE }}>Substitution Schedule</h3>
                    <pre className="whitespace-pre-wrap font-mono text-sm leading-relaxed" style={{ color: COLORS.NAVY_BLUE }}>
                      {matchPlan || 'Press "Generate Match Plan" to see the schedule here. Match info will display the selected periods for 5v5.'}
                    </pre>
                  </div>

                  <div className="p-6 rounded-xl shadow-xl bg-white">
                    <h3 className="text-xl font-bold mb-4 border-b pb-2" style={{ color: COLORS.NAVY_BLUE, borderColor: COLORS.SKY_BLUE }}>
                      Live Formation Visual
                    </h3>
                        
                    {/* PremiereShip Sub Timeline */}
                    {isPremiership && matchLineups.length > 1 && (
                        <SubstitutionTimeline 
                            lineups={matchLineups}
                            currentLineupIndex={currentLineupIndex}
                            setCurrentLineupIndex={setCurrentLineupIndex}
                        />
                    )}
                    {/* Main Visualizer */}
                    {settings.selectedFormation && (
                      <PositionVisualizer 
                            settings={settings} 
                            lineups={matchLineups.length > 0 ? matchLineups : [{ players: displayedPlayers.map(p => ({...p, position: p.preferredPosition || 'Bench'})), time: 'Current Roster'}]} 
                            currentLineupIndex={currentLineupIndex}
                            isPremiership={isPremiership}
                        />
                    )}
                  </div>
                </div>
              </div>

            </div>
          );
        };

        // Render the application into the 'root' div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
