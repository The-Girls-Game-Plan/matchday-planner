<!DOCTYPE html>
<html>
<head>
    <title>The Girls' Game Planner</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom CSS to ensure default fonts and layout */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* Custom scrollbar style for player lists */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #56B0D5; /* SKY_BLUE */
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: #f0f4f8;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Global utility to generate unique IDs
        const generateUUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });

        // Mock components for Lucide icons 
        const User = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1rem', height: '1rem'}}>ğŸ‘¤</span>;
        const Settings = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.5rem', height: '1.5rem'}}>âš™ï¸</span>;
        const Play = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.25rem', height: '1.25rem'}}>â–¶ï¸</span>;
        const Save = ({ className = '', style = {}, color = 'currentColor' }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.25rem', height: '1.25rem', color}}>ğŸ’¾</span>;
        const Unlock = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1rem', height: '1rem'}}>ğŸ”‘</span>;
        const Loader2 = ({ className = '', style = {} }) => <span className={`${className} animate-spin`} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1.25rem', height: '1.25rem'}}>ğŸ”„</span>;
        const Star = ({ className = '', style = {} }) => <span className={className} style={{...style, display: 'inline-flex', alignItems: 'center', lineHeight: '1', width: '1rem', height: '1rem'}}>â­</span>;


        const { useState, useEffect, useMemo, useCallback } = React;
        
        // --- MOCK FIREBASE LIBRARIES (FOR SINGLE-FILE EXECUTION) ---
        window.__app_id = 'mock-app';
        window.__firebase_config = JSON.stringify({ apiKey: "mock-key", authDomain: "mock-domain", projectId: "mock-project" });
        window.__initial_auth_token = 'mock-token';

        const mockDbData = new Map();

        const retryFetch = async (apiCall, maxRetries = 1) => {
            return await apiCall();
        };

        const getPrivatePath = (collectionName, userId) => {
            const appId = window.__app_id || 'default-app-id';
            return `mock_db:${appId}:${userId}:${collectionName}`;
        };

        const useFirebase = () => {
            const [userId] = useState('mock-user-12345');
            const [isAuthReady] = useState(true);
            const [error] = useState(null);

            const mockFirestore = useMemo(() => ({
                collection: (path) => ({ path }),
                query: (collectionRef) => ({ ...collectionRef }),
                getDocs: async (q) => {
                    const prefix = `${q.path}:`;
                    const docs = Array.from(mockDbData.entries())
                        .filter(([key]) => key.startsWith(prefix))
                        .map(([key, value]) => ({
                            id: key.split(':').pop(),
                            data: () => value
                        }));
                    return { docs };
                },
                doc: (collectionRef, id = generateUUID()) => ({ path: collectionRef.path, id }),
                setDoc: async (docRef, data) => {
                    mockDbData.set(`${docRef.path}:${docRef.id}`, data);
                },
                deleteDoc: async (docRef) => {
                    mockDbData.delete(`${docRef.path}:${docRef.id}`);
                }
            }), []);


            const firestorePath = useMemo(() => {
                if (userId) {
                    return getPrivatePath('squads', userId);
                }
                return null;
            }, [userId]);

            return { db: mockFirestore, userId, isAuthReady, firestorePath, appId: window.__app_id, error };
        };


        // --- CONFIGURATION & CONSTANTS ---

        const COLORS = {
        Â  NAVY_BLUE: '#193755', 
        Â  ORANGE: '#E97227', 
        Â  SKY_BLUE: '#56B0D5', 
        Â  WHITE: '#FFFFFF',
        Â  GOLD: '#AF9542', 
        };

        const MATCH_DURATIONS = {
        Â  '5v5': 40,
        Â  '7v7': 50,
        Â  '9v9': 60,
        Â  '11v11': 70, 
        };

        // --- UPDATED FORMATIONS STRUCTURE ---
        const FORMATIONS = {
            '5v5': [
                { name: '1-2-1', slots: ['CD', 'CM-R', 'CM-L', 'ST'], maxPlayers: 4 },
                { name: '2-1-1', slots: ['CD-R', 'CD-L', 'CM', 'ST'], maxPlayers: 4 },
                { name: '1-1-2', slots: ['CD', 'CM', 'ST-R', 'ST-L'], maxPlayers: 4 },
            ],
            '7v7': [
                { name: '2-1-3', slots: ['CD-R', 'CD-L', 'CM', 'ST-R', 'ST-L', 'ST'], maxPlayers: 6 },
                { name: '2-2-2', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'ST-R', 'ST-L'], maxPlayers: 6 },
                { name: '1-3-2', slots: ['CD', 'CM-R', 'CM-L', 'CM', 'ST-R', 'ST-L'], maxPlayers: 6 },
                { name: '2-3-1', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'CM', 'ST'], maxPlayers: 6 },
                { name: '1-2-3', slots: ['CD', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'ST'], maxPlayers: 6 },
                { name: '1-4-1', slots: ['CD', 'CM-R', 'CM-L', 'RW', 'LW', 'ST'], maxPlayers: 6 },
            ],
            '9v9': [
                { name: '3-2-3', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'ST'], maxPlayers: 8 },
                { name: '3-3-2', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'CDM', 'ST-R', 'ST-L'], maxPlayers: 8 },
                { name: '3-4-1', slots: ['CD-R', 'CD-L', 'CD', 'RB', 'LB', 'CM', 'CDM', 'ST'], maxPlayers: 8 },
                { name: '3-2-1-2', slots: ['CD-R', 'CD-L', 'CD', 'CDM-R', 'CDM-L', 'CAM', 'ST-R', 'ST-L'], maxPlayers: 8 },
                { name: '2-4-2', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'CDM', 'CAM', 'ST-R', 'ST-L'], maxPlayers: 8 },
                { name: '2-3-3', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'CDM', 'ST-R', 'ST-L', 'ST'], maxPlayers: 8 },
                { name: '2-2-4', slots: ['CD-R', 'CD-L', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'RW', 'LW'], maxPlayers: 8 },
            ],
            '11v11': [
                { name: '4-4-2', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'RW', 'LW', 'CM-R', 'CM-L', 'ST-R', 'ST-L'], maxPlayers: 10 },
                { name: '4-3-3', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CM-R', 'CM-L', 'CDM', 'RW', 'LW', 'ST'], maxPlayers: 10 },
                { name: '4-2-3-1', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CDM-R', 'CDM-L', 'RW', 'LW', 'CAM', 'ST'], maxPlayers: 10 },
                { name: '4-1-4-1', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CDM', 'CM-R', 'CM-L', 'RW', 'LW', 'ST'], maxPlayers: 10 },
                { name: '4-2-4', slots: ['RB', 'LB', 'CD-R', 'CD-L', 'CM-R', 'CM-L', 'ST-R', 'ST-L', 'RW', 'LW'], maxPlayers: 10 },
                { name: '3-5-2', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'CDM', 'CAM', 'RW', 'ST-R', 'ST-L'], maxPlayers: 10 },
                { name: '3-4-3', slots: ['CD-R', 'CD-L', 'CD', 'CM-R', 'CM-L', 'CDM', 'CAM', 'RW', 'LW', 'ST'], maxPlayers: 10 },
            ],
        };

        const ALL_POSITIONS = [
        Â  'GK', 'CD', 'CD-R', 'CD-L', 'RB', 'LB', 'CM', 'CM-R', 'CM-L',
        Â  'CDM', 'CAM', 'RW', 'LW', 'ST', 'ST-R', 'ST-L'
        ];
        
        // --- CORE MATCH PLANNER LOGIC ---

        const getOutfieldSlots = (gameFormat, selectedFormation) => {
            const formatArray = FORMATIONS[gameFormat];
            const formation = formatArray ? formatArray.find(f => f.name === selectedFormation) : null;
            return formation ? formation.slots : [];
        };

        const getOutfieldMaxPlayers = (gameFormat) => {
            const formatArray = FORMATIONS[gameFormat];
            // Since all formations for a format must have the same number of outfield players, grab the first one
            return formatArray && formatArray.length > 0 ? formatArray[0].maxPlayers : 0;
        };


        const calculateEqualMinutes = (settings, players) => {
        Â  const { gameFormat, matchDuration, isPermanentGK } = settings;
        Â  if (!matchDuration || matchDuration <= 0 || players.length === 0) return players;
        Â  
        Â  const outfieldSpots = getOutfieldMaxPlayers(gameFormat);
        Â  const outfieldPlayers = players.filter(p => p.role !== 'GK');
        Â  const numOutfieldPlayers = outfieldPlayers.length;
        Â  if (numOutfieldPlayers === 0) return players;

        Â  const totalOutfieldMinutesAvailable = outfieldSpots * matchDuration;
        Â  const baseEqualTime = Math.floor(totalOutfieldMinutesAvailable / numOutfieldPlayers);
        Â  let remainderMinutes = totalOutfieldMinutesAvailable % numOutfieldPlayers;

        Â  const updatedPlayers = players.map((player) => {
        Â  Â  if (player.role === 'GK') {
        Â  Â  Â  return { ...player, minutes: isPermanentGK ? matchDuration : 0 };
        Â  Â  }

        Â  Â  let finalMinutes = baseEqualTime;
        Â  Â  if (remainderMinutes > 0) {
        Â  Â  Â  finalMinutes += 1;
        Â  Â  Â  remainderMinutes--;
        Â  Â  }

        Â  Â  const effectiveMinutes = player.manualMinutes !== null ? player.manualMinutes : finalMinutes;
        Â  Â  return { ...player, minutes: effectiveMinutes };
        Â  });

        Â  return updatedPlayers;
        };

        const generateAutomaticPlan = (settings, playersWithMinutes) => {
        Â  const { gameFormat, matchDuration, selectedFormation, subInterval, firstSubTime, maxSubs, matchPeriods } = settings;
        Â  const positions = getOutfieldSlots(gameFormat, selectedFormation);
        Â  const outfieldSpots = positions.length;

        Â  const periods = gameFormat === '5v5' && matchPeriods === 'Quarters' ? 4 : 2;
        Â  const halfDuration = matchDuration / 2;
        Â  const periodDuration = matchDuration / periods;

        Â  let outfieldPlayers = playersWithMinutes
        Â  Â  .filter(p => p.role !== 'GK' && p.minutes > 0)
        Â  Â  .sort((a, b) => a.minutes - b.minutes);

        Â  const gkPlayer = playersWithMinutes.find(p => p.role === 'GK');
          const allPlayers = playersWithMinutes;

        Â  if (outfieldPlayers.length <= outfieldSpots) {
        Â  Â  return {
                planText: `--- Match Info ---\nFormat: ${gameFormat} (${matchPeriods})\nDuration: ${matchDuration} min (${periods} x ${periodDuration} min periods)\n\nAll participating players can play the full match duration based on the squad size and game format. No substitutions required for minutes management.`,
                lineups: [{ time: '0:00 (Start)', players: allPlayers.map(p => ({ ...p, position: p.startingPosition || 'Bench' })) }]
            };
        Â  }

        Â  let plan = `--- Match Info ---\nFormat: ${gameFormat} (${matchPeriods})\nDuration: ${matchDuration} min (Half: ${halfDuration} min)\n\n`;
        Â  plan += `GK: ${gkPlayer ? gkPlayer.name : 'Unassigned GK'}\n`;
        Â  plan += `Formation: ${selectedFormation} (${outfieldSpots} outfield slots)\n\n`;
        Â Â 
        Â  let playing = [];
        Â  let bench = [];
        Â  let rotationQueue = [...outfieldPlayers];
        Â  let subCount = 0;
          let lineups = []; 

        Â  // 1. Assign starters and bench for the FIRST HALF
        Â  // Use the StartingPosition if available, otherwise rely on minute priority
          const startersWithPositions = players.filter(p => p.startingPosition);
          const customStarters = startersWithPositions.filter(p => p.startingPosition !== 'GK').slice(0, outfieldSpots);
          
          if (customStarters.length === outfieldSpots) {
              playing = customStarters;
              rotationQueue = outfieldPlayers.filter(p => !customStarters.map(s => s.id).includes(p.id));
              bench = rotationQueue;
          } else {
              // Fallback to minutes priority for starting lineup
              for (let i = 0; i < outfieldSpots; i++) {
        Â  Â        playing.push(rotationQueue.shift());Â 
        Â      }
        Â      bench = rotationQueue;
          }

          // Record starting lineup
          lineups.push({ 
              time: '0:00 (Start)', 
              players: allPlayers.map(p => ({ 
                  ...p, 
                  position: p.role === 'GK' ? 'GK' : (playing.find(pl => pl.id === p.id) ? positions[playing.findIndex(pl => pl.id === p.id)] : 'Bench') 
              }))
          });
        Â Â 
        Â  let currentPeriodMinutes = new Map(outfieldPlayers.map(p => [p.id, 0]));

        Â  plan += `--- STARTING LINEUP (0:00) ---\n`;
        Â  playing.forEach((p, i) => {
        Â  Â  plan += `${positions[i]}: ${p.name} (Target Mins/Half: ${Math.ceil(p.minutes / periods * 2)})\n`; 
        Â  });
        Â  plan += `\n`;

        Â  for (let period = 1; period <= periods; period++) {
        Â  Â  const periodStart = (period - 1) * periodDuration;
        Â  Â  const periodEnd = period * periodDuration;
        Â  Â  let time = periodStart + firstSubTime;
        Â  Â  let lastSubTime = periodStart;
        Â  Â Â 
        Â  Â  if (period > 1) {
        Â  Â  Â  Â  const periodName = periods === 4 ? `QUARTER ${period}` : `SECOND HALF`;
        Â  Â  Â  Â  plan += `\n*** ${periodName} START (${periodStart}:00) - ROTATION RESET FOR EVEN MINUTES ***\n\n`;

        Â  Â  Â  Â  const allPlayersInRotation = [...playing, ...bench];
        Â  Â  Â  Â Â 
        Â  Â  Â  Â  let newPlaying = allPlayersInRotation.filter(p => bench.map(b => b.id).includes(p.id)).slice(0, outfieldSpots);
        Â  Â  Â  Â  let newBench = allPlayersInRotation.filter(p => !newPlaying.map(np => np.id).includes(p.id));

        Â  Â  Â  Â  playing = newPlaying;
        Â  Â  Â  Â  bench = newBench;
        Â  Â  Â  Â Â 
        Â  Â  Â  Â  currentPeriodMinutes.forEach((v, k) => currentPeriodMinutes.set(k, 0));
        Â  Â  Â  Â Â 
        Â  Â  Â  Â  plan += `--- STARTING LINEUP (${periodStart}:00) ---\n`;
        Â  Â  Â  Â  playing.forEach((p, i) => {
        Â  Â  Â  Â  Â  Â  plan += `${positions[i]}: ${p.name}\n`;
        Â  Â  Â  Â  });
        Â  Â  Â  Â  plan += `\n`;

                // Record Half/Quarter Start Lineup
                lineups.push({ 
                    time: `${periodStart}:00 (${periodName})`, 
                    players: allPlayers.map(p => ({ 
                        ...p, 
                        position: p.role === 'GK' ? 'GK' : (playing.find(pl => pl.id === p.id) ? positions[playing.findIndex(pl => pl.id === p.id)] : 'Bench') 
                    }))
                });
        Â  Â  Â  Â Â 
        Â  Â  Â  Â  time = periodStart + firstSubTime;
        Â  Â  Â  Â  lastSubTime = periodStart;
        Â  Â  }


        Â  Â  while (time <= periodEnd) {
        Â  Â  Â  if (bench.length === 0) break;

        Â  Â  Â  const elapsed = time - lastSubTime;
        Â  Â  Â  const outgoingCandidates = [];

        Â  Â  Â  playing.forEach((player, index) => {
        Â  Â  Â  Â  Â  currentPeriodMinutes.set(player.id, currentPeriodMinutes.get(player.id) + elapsed);
        Â  Â  Â  Â  Â  outgoingCandidates.push({Â 
        Â  Â  Â  Â  Â  Â  Â  player,Â 
        Â  Â  Â  Â  Â  Â  Â  position: positions[index],Â 
        Â  Â  Â  Â  Â  Â  Â  index,
        Â  Â  Â  Â  Â  Â  Â  periodTimePlayed: currentPeriodMinutes.get(player.id)
        Â  Â  Â  Â  Â  });
        Â  Â  Â  });
        Â  Â  Â Â 
        Â  Â  Â  outgoingCandidates.sort((a, b) => b.periodTimePlayed - a.periodTimePlayed);
        Â  Â  Â Â 
        Â  Â  Â  const subsForThisWindow = Math.min(maxSubs, bench.length, outgoingCandidates.length);
        Â  Â  Â  const subsBlock = [];
        Â  Â  Â Â 
        Â  Â  Â  const playersToSubOut = outgoingCandidates.slice(0, subsForThisWindow);
        Â  Â  Â  let incomingCandidates = [...bench].sort((a, b) => a.minutes - b.minutes);
        Â  Â  Â Â 
        Â  Â  Â  playersToSubOut.forEach((outgoing) => {
        Â  Â  Â  Â  Â  const position = outgoing.position;
        Â  Â  Â  Â  Â  const incoming = incomingCandidates.shift();
        Â  Â  Â  Â  Â  if (!incoming) return;

        Â  Â  Â  Â  Â  playing[outgoing.index] = incoming;
        Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  subsBlock.push({
        Â  Â  Â  Â  Â  Â  Â  on: incoming,
        Â  Â  Â  Â  Â  Â  Â  off: outgoing.player,
        Â  Â  Â  Â  Â  Â  Â  position: position,
        Â  Â  Â  Â  Â  Â  Â  index: outgoing.index
        Â  Â  Â  Â  Â  });
        Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  bench = bench.filter(p => p.id !== incoming.id);
        Â  Â  Â  Â  Â  bench.push(outgoing.player);
        Â  Â  Â  });

        Â  Â  Â  if (subsBlock.length > 0) {
        Â  Â  Â  Â  Â  subCount += subsBlock.length;
        Â  Â  Â  Â  Â  plan += `--- Substitution at ${String(time).padStart(2, '0')}:00 ---\n`;
        Â  Â  Â  Â  Â  subsBlock.forEach(sub => {
        Â  Â  Â  Â  Â  Â  Â  plan += `ON: ${sub.on.name} (${sub.position} slot) | OFF: ${sub.off.name}\n`;
        Â  Â  Â  Â  Â  });
        Â  Â  Â  Â  Â  plan += `\n`;
                
                // Record the substitution lineup
                lineups.push({ 
                    time: `${String(time).padStart(2, '0')}:00 (Sub)`, 
                    players: allPlayers.map(p => ({ 
                        ...p, 
                        position: p.role === 'GK' ? 'GK' : (playing.find(pl => pl.id === p.id) ? positions[playing.findIndex(pl => pl.id === p.id)] : 'Bench') 
                    }))
                });
        Â  Â  Â  }
        Â  Â  Â Â 
        Â  Â  Â  lastSubTime = time;
        Â  Â  Â  time += subInterval;

        Â  Â  Â  if (time > periodEnd) break;
        Â  Â  }
        Â  }

        Â  plan += `--- Match End (${matchDuration}:00) ---\n`;
        Â  plan += `Total substitutions made: ${subCount}. \n\n`;
        Â  plan += '***Note: This automatic plan ensures equal minutes across the two halves by resetting the playing/bench queues at halftime. The positions are fixed based on the starting formation.***';

        Â  return { planText: plan, lineups };
        };


        // --- UI COMPONENTS ---

        const PlayerInputRow = ({ player, index, settings, setPlayers, subscriptionTier, allPositions }) => {
        Â  const isChampionship = subscriptionTier !== 'Basic';
        Â  const isPremiership = subscriptionTier === 'Premiership';
          const availablePositions = ALL_POSITIONS.filter(p => p !== 'GK' || index === 0);

        Â  const handleChange = (field, value) => {
        Â  Â  setPlayers(prev => prev.map(p => {
                if (p.id !== player.id) return p;

                let updated = { ...p, [field]: value };

                // Logic for Starting Position -> Preferred Position auto-mirror
                if (field === 'startingPosition' && value !== '') {
                    updated.preferredPosition = value;
                }
                
                // Logic for GK role management
                if (updated.preferredPosition === 'GK') {
                    updated.role = 'GK';
                } else if (p.role === 'GK' && index !== 0) {
                     updated.role = 'Outfield';
                } else if (p.role === 'GK' && index === 0 && updated.preferredPosition !== 'GK') {
                     updated.role = 'Outfield';
                }

                return updated;
            }));
        Â  };
            
        Â  return (
        Â  Â  <div className="flex items-center space-x-2 py-2 border-b border-gray-100">
        Â  Â  Â  <span className="text-xs font-semibold w-6 text-center text-gray-500">{index + 1}</span>
        Â  Â  Â  <input
        Â  Â  Â  Â  type="text"
        Â  Â  Â  Â  placeholder={`Player Name ${index + 1}`}
        Â  Â  Â  Â  value={player.name}
        Â  Â  Â  Â  onChange={(e) => handleChange('name', e.target.value)}
        Â  Â  Â  Â  className="flex-grow p-2 border rounded-lg focus:ring-sky-blue focus:border-sky-blue transition duration-150"
        Â  Â  Â  />
                {/* NEW: Starting Position (mirrors to Preferred Position) */}
                <select
                    value={player.startingPosition || ''}
                    onChange={(e) => handleChange('startingPosition', e.target.value)}
                    className="p-2 border rounded-lg w-28 text-sm bg-white"
                >
                    <option value="">Start Pos.</option>
                    {availablePositions.map(pos => <option key={`start-${pos}`} value={pos}>{pos}</option>)}
                </select>

                {/* Preferred Position (manual override allowed) */}
        Â  Â  Â  <select
        Â  Â  Â  Â  value={player.preferredPosition}
        Â  Â  Â  Â  onChange={(e) => handleChange('preferredPosition', e.target.value)}
        Â  Â  Â  Â  className="p-2 border rounded-lg w-28 text-sm bg-white"
        Â  Â  Â  >
        Â  Â  Â  Â  <option value="">Pref. Pos.</option>
        Â  Â  Â  Â  {availablePositions.map(pos => <option key={`pref-${pos}`} value={pos}>{pos}</option>)}
        Â  Â  Â  </select>

        Â  Â  Â  {isChampionship && (
        Â  Â  Â  Â  <select
        Â  Â  Â  Â  Â  value={player.secondaryPosition}
        Â  Â  Â  Â  Â  onChange={(e) => handleChange('secondaryPosition', e.target.value)}
        Â  Â  Â  Â  Â  className={`p-2 border rounded-lg w-28 text-sm bg-white`}
        Â  Â  Â  Â  >
        Â  Â  Â  Â  Â  <option value="">Sec. Pos.</option>
        Â  Â  Â  Â  Â  {availablePositions.map(pos => <option key={`sec-${pos}`} value={pos}>{pos}</option>)}
        Â  Â  Â  Â  </select>
        Â  Â  Â  )}

        Â  Â  Â  {isPremiership && (
        Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  type="number"
        Â  Â  Â  Â  Â  placeholder="Manual Mins"
        Â  Â  Â  Â  Â  value={player.manualMinutes === null ? '' : player.manualMinutes}
        Â  Â  Â  Â  Â  onChange={(e) => handleChange('manualMinutes', e.target.value === '' ? null : parseInt(e.target.value, 10))}
        Â  Â  Â  Â  Â  className={`p-2 border rounded-lg w-24 text-sm text-center`}
        Â  Â  Â  Â  />
        Â  Â  Â  )}
        Â  Â  </div>
        Â  );
        };

        const PlayerCircle = ({ name, position, isGK, color = COLORS.SKY_BLUE, yPos, xPos }) => {
            // Displays position code inside the circle
            const displayPos = position.length > 4 ? position.replace('-', '/') : position;
            const firstName = name.split(' ')[0];
            
            return (
        Â  <div
        Â  Â  className="absolute flex flex-col items-center justify-center transition-all duration-500 ease-in-out"
        Â  Â  style={{ top: `${yPos}%`, left: `${xPos}%`, transform: 'translate(-50%, -50%)', zIndex: Math.round(yPos) }}
        Â  Â  title={`${name} (${position})`}
        Â  >
        Â  Â  <div
        Â  Â  Â  className="w-12 h-12 rounded-full flex items-center justify-center text-xs font-bold text-white shadow-lg border-2"
        Â  Â  Â  style={{
        Â  Â  Â  Â  backgroundColor: color,
        Â  Â  Â  Â  borderColor: isGK ? COLORS.ORANGE : color,
        Â  Â  Â  }}
        Â  Â  >
        Â  Â  Â  {displayPos || 'POS'}
        Â  Â  </div>
        Â  Â  <span className={`text-xs mt-1 font-medium text-center`} style={{ color: COLORS.NAVY_BLUE }}>{firstName}</span>
        Â  </div>
        )};


        const PositionVisualizer = ({ settings, lineups, currentLineupIndex, isPremiership }) => {
        Â  const { gameFormat, selectedFormation } = settings;

          const displayLineup = lineups[currentLineupIndex] || { players: [], time: 'N/A' };
          
          const playersOnField = displayLineup.players.filter(p => p.position !== 'Bench' && p.name.trim() !== '');

        Â  const getPositionCoordinates = (position) => {
        Â  Â  const map = {
        Â  Â  Â  Â  GK: { y: 95, x: 50 },
        Â  Â  Â  Â  RB: { y: 80, x: 15 }, LB: { y: 80, x: 85 },
        Â  Â  Â  Â  CD: { y: 85, x: 50 }, 'CD-R': { y: 85, x: 30 }, 'CD-L': { y: 85, x: 70 },
        Â  Â  Â  Â  CDM: { y: 70, x: 50 }, 'CDM-R': { y: 70, x: 25 }, 'CDM-L': { y: 70, x: 75 },
        Â  Â  Â  Â  CM: { y: 50, x: 50 }, 'CM-R': { y: 50, x: 20 }, 'CM-L': { y: 50, x: 80 },
        Â  Â  Â  Â  CAM: { y: 35, x: 50 },
        Â  Â  Â  Â  RW: { y: 20, x: 10 }, LW: { y: 20, x: 90 },
        Â  Â  Â  Â  ST: { y: 15, x: 50 }, 'ST-R': { y: 18, x: 30 }, 'ST-L': { y: 18, x: 70 },
        Â  Â  };
        Â  Â  return map[position] || { y: 50, x: 50 };
        Â  };

        Â  const visualPlayers = playersOnField.map((player) => {
        Â  Â  const { y, x } = getPositionCoordinates(player.position);
            const isGK = player.position === 'GK';
        Â  Â  const color = isGK ? COLORS.NAVY_BLUE : COLORS.SKY_BLUE;
        Â  Â  return <PlayerCircle key={player.id} name={player.name} position={player.position} isGK={isGK} color={color} yPos={y} xPos={x} />;
        Â  });


          if (!isPremiership && currentLineupIndex > 0 && lineups.length > 1) {
            return (
                <div className="flex items-center justify-center w-full h-96 border-4 border-dashed rounded-xl" style={{ borderColor: COLORS.GOLD, color: COLORS.GOLD }}>
                    <div className="text-center p-4">
                        <Star className="w-10 h-10 mx-auto fill-current mb-2" />
                        <p className="font-bold text-lg">Visual Timeline (Premiership Only)</p>
                        <p className="text-sm mt-1">Upgrade to view and step through the full match substitution sequence.</p>
                    </div>
                </div>
            )
          }

        Â  return (
        Â  Â  <div className="relative w-full h-96 border-4 border-green-800 bg-green-700/80 rounded-xl overflow-hidden shadow-inner">
        Â  Â  Â  <div className="absolute inset-0 border-white border-2 m-4 rounded-lg opacity-80">
        Â  Â  Â  Â  <div className="absolute top-1/2 left-1/2 w-20 h-20 border-white border-2 rounded-full transform -translate-x-1/2 -translate-y-1/2 opacity-80"></div>
        Â  Â  Â  Â  <div className="absolute top-0 left-1/2 w-40 h-10 border-white border-2 transform -translate-x-1/2"></div>
        Â  Â  Â  Â  <div className="absolute bottom-0 left-1/2 w-40 h-10 border-white border-2 transform -translate-x-1/2 -scale-y-100"></div>
        Â  Â  Â  </div>

        Â  Â  Â  {visualPlayers}

        Â  Â  Â  <div className="absolute bottom-2 right-2 text-xs font-semibold text-white bg-black/50 p-1 rounded">
        Â  Â  Â  Â  {settings.gameFormat} - {selectedFormation} ({displayLineup.time})
        Â  Â  Â  </div>
        Â  Â  </div>
        Â  );
        };
        
        const SubscriptionBadge = ({ tier }) => {
        Â  let color, icon, text;

        Â  if (tier === 'Premiership') {
        Â  Â  color = COLORS.GOLD;
        Â  Â  icon = <Star className="w-4 h-4 text-white fill-current mr-1" />;
        Â  Â  text = 'Premiership';
        Â  } else if (tier === 'Championship') {
        Â  Â  color = COLORS.SKY_BLUE;
        Â  Â  icon = <Unlock className="w-4 h-4 text-white mr-1" />;
        Â  Â  text = 'Championship';
        Â  } else {
        Â  Â  color = COLORS.NAVY_BLUE;
        Â  Â  icon = null;
        Â  Â  text = 'Basic (FREE)';
        Â  }

        Â  return (
        Â  Â  <div
        Â  Â  Â  className="px-3 py-1 rounded-full text-xs font-bold flex items-center shadow-md"
        Â  Â  Â  style={{ backgroundColor: color, color: COLORS.WHITE }}
        Â  Â  >
        Â  Â  Â  {icon}
        Â  Â  Â  {text}
        Â  Â  </div>
        Â  );
        };

        const Button = ({ children, color = COLORS.ORANGE, disabled, onClick }) => (
        Â  <button
        Â  Â  onClick={onClick}
        Â  Â  disabled={disabled}
        Â  Â  className={`flex items-center justify-center px-6 py-3 rounded-xl font-bold text-white shadow-lg transition duration-200 ${
        Â  Â  Â  disabled
        Â  Â  Â  Â  ? 'opacity-50 cursor-not-allowed bg-gray-400'
        Â  Â  Â  Â  : 'hover:opacity-90 active:scale-[0.98]'
        Â  Â  }`}
        Â  Â  style={{ backgroundColor: color }}
        Â  >
        Â  Â  {children}
        Â  </button>
        );

        const SubstitutionTimeline = ({ lineups, currentLineupIndex, setCurrentLineupIndex }) => {
            if (lineups.length <= 1) return null;

            const maxIndex = lineups.length - 1;

            return (
                <div className="mt-4 flex items-center space-x-2 p-2 bg-gray-100 rounded-lg border-t border-b" style={{ borderColor: COLORS.SKY_BLUE }}>
                    <span className="font-semibold text-sm" style={{ color: COLORS.NAVY_BLUE }}>View Lineup:</span>
                    <button 
                        onClick={() => setCurrentLineupIndex(Math.max(0, currentLineupIndex - 1))}
                        disabled={currentLineupIndex === 0}
                        className="p-1 px-3 text-sm bg-gray-300 rounded disabled:opacity-50"
                    >
                        &lt; Previous
                    </button>
                    <div className="flex-grow text-center font-mono text-sm font-bold" style={{ color: COLORS.ORANGE }}>
                        {lineups[currentLineupIndex].time} (Event {currentLineupIndex + 1} of {lineups.length})
                    </div>
                    <button 
                        onClick={() => setCurrentLineupIndex(Math.min(maxIndex, currentLineupIndex + 1))}
                        disabled={currentLineupIndex === maxIndex}
                        className="p-1 px-3 text-sm bg-gray-300 rounded disabled:opacity-50"
                    >
                        Next &gt;
                    </button>
                </div>
            );
        };


        // --- MAIN APPLICATION COMPONENT ---

        const App = () => {
        Â  const { db, userId, isAuthReady, firestorePath, error } = useFirebase();

        Â  const [subscriptionTier, setSubscriptionTier] = useState('Premiership');

        Â  const [settings, setSettings] = useState(() => {
        Â  Â  const defaultFormat = '9v9';
        Â  Â  return {
        Â  Â  Â  gameFormat: defaultFormat,
        Â  Â  Â  matchDuration: MATCH_DURATIONS[defaultFormat],
        Â  Â  Â  squadSize: 11,
        Â  Â  Â  isPermanentGK: true,
        Â  Â  Â  selectedFormation: '3-3-2',
        Â  Â  Â  planType: 'Automatic',Â 
        Â  Â  Â  subInterval: 10,
        Â  Â  Â  firstSubTime: 10,
        Â  Â  Â  maxSubs: 2,
        Â  Â  Â  matchPeriods: 'Halves',Â 
        Â  Â  };
        Â  });
        Â Â 
        Â  const [players, setPlayers] = useState(
        Â  Â  Array.from({ length: 20 }, (_, i) => ({
        Â  Â  Â  id: generateUUID(),
        Â  Â  Â  name: i === 0 ? 'Ella (GK)' : i === 1 ? 'Mia' : i < 11 ? `Player ${i + 1}` : '',
        Â  Â  Â  role: i === 0 ? 'GK' : 'Outfield',
              startingPosition: i === 0 ? 'GK' : '', 
        Â  Â  Â  preferredPosition: i === 0 ? 'GK' : '',
        Â  Â  Â  secondaryPosition: '',
        Â  Â  Â  manualMinutes: null,
        Â  Â  }))
        Â  );

        Â  const [matchPlan, setMatchPlan] = useState('');
          const [matchLineups, setMatchLineups] = useState([]);
          const [currentLineupIndex, setCurrentLineupIndex] = useState(0);

        Â  const [isGenerating, setIsGenerating] = useState(false);
        Â  const [savedSquads, setSavedSquads] = useState([]);
        Â  const [isSavingLoading, setIsSavingLoading] = useState(false);


        Â  const maxSquads = subscriptionTier === 'Championship' ? 2 : Infinity;
        Â  const isChampionship = subscriptionTier !== 'Basic';
        Â  const isPremiership = subscriptionTier === 'Premiership';
        Â  const outfieldSpots = getOutfieldMaxPlayers(settings.gameFormat);
        Â  const formationsAvailable = FORMATIONS[settings.gameFormat];

        Â  const activePlayers = useMemo(() => players.filter(p => p.name.trim() !== ''), [players]);

        Â  const displayedPlayers = useMemo(() => players.slice(0, settings.squadSize), [players, settings.squadSize]);

        Â  useEffect(() => {
        Â  Â  const duration = MATCH_DURATIONS[settings.gameFormat];
            // Find the default formation name based on the old structure of setting the first key
        Â  Â  const defaultFormation = formationsAvailable && formationsAvailable.length > 0 ? formationsAvailable[0].name : '';
        Â  Â Â 
        Â  Â  setSettings(prev => ({Â 
        Â  Â  Â  ...prev,Â 
        Â  Â  Â  matchDuration: duration,
        Â  Â  Â  selectedFormation: defaultFormation,
        Â  Â  Â  matchPeriods: settings.gameFormat === '5v5' ? prev.matchPeriods : 'Halves',Â 
        Â  Â  }));
        Â  }, [settings.gameFormat]);

        Â  const fetchSquads = useCallback(async () => {
        Â  Â  if (!isAuthReady || !db || !firestorePath) return;

        Â  Â  setIsSavingLoading(true);
        Â  Â  try {
        Â  Â  Â  const collectionRef = db.collection(firestorePath);
        Â  Â  Â  const q = db.query(collectionRef);
        Â  Â  Â Â 
        Â  Â  Â  const docs = await retryFetch(() => db.getDocs(q));

        Â  Â  Â  const squads = docs.docs.map(d => ({
        Â  Â  Â  Â  id: d.id,
        Â  Â  Â  Â  name: d.data().name,
        Â  Â  Â  Â  data: d.data().players,
        Â  Â  Â  }));
        Â  Â  Â  setSavedSquads(squads);

        Â  Â  } catch (e) {
        Â  Â  Â  console.error('Error fetching squads:', e);
        Â  Â  } finally {
        Â  Â  Â  setIsSavingLoading(false);
        Â  Â  }
        Â  }, [db, firestorePath, isAuthReady]);

        Â  useEffect(() => {
        Â  Â  if (isChampionship) {
        Â  Â  Â  fetchSquads();
        Â  Â  }
        Â  }, [isChampionship, fetchSquads]);


        Â  const handleSaveSquad = async () => {
        Â  Â  if (!isChampionship || (!isPremiership && savedSquads.length >= maxSquads)) {
        Â  Â  Â  console.error('Cannot save: Subscription limits reached.');
        Â  Â  Â  return;
        Â  Â  }

        Â  Â  const squadName = `Squad ${new Date().toLocaleTimeString()} (${settings.gameFormat})`;

        Â  Â  if (!squadName) return;

        Â  Â  setIsSavingLoading(true);
        Â  Â  try {
        Â  Â  Â  const squadData = {
        Â  Â  Â  Â  name: squadName,
        Â  Â  Â  Â  players: displayedPlayers.filter(p => p.name.trim() !== ''),
        Â  Â  Â  Â  createdAt: new Date().toISOString(),
        Â  Â  Â  };
        Â  Â  Â Â 
        Â  Â  Â  const collectionRef = db.collection(firestorePath);
        Â  Â  Â  const newDocRef = db.doc(collectionRef);
        Â  Â  Â  await retryFetch(() => db.setDoc(newDocRef, squadData));
        Â  Â  Â Â 
        Â  Â  Â  console.log('Squad saved successfully.');
        Â  Â  Â  fetchSquads();
        Â  Â  } catch (e) {
        Â  Â  Â  console.error('Error saving squad:', e);
        Â  Â  } finally {
        Â  Â  Â  setIsSavingLoading(false);
        Â  Â  }
        Â  };

        Â  const handleLoadSquad = (squadData) => {
        Â  Â  const loadedPlayers = squadData.map((p, i) => ({ ...p, id: p.id || generateUUID() }));
        Â  Â  setSettings(prev => ({ ...prev, squadSize: loadedPlayers.length }));

        Â  Â  const newPlayers = Array.from({ length: 20 }, (_, i) => {
        Â  Â  Â  if (i < loadedPlayers.length) {
        Â  Â  Â  Â  return loadedPlayers[i];
        Â  Â  Â  }
        Â  Â  Â  return { id: generateUUID(), name: '', role: 'Outfield', startingPosition: '', preferredPosition: '', secondaryPosition: '', manualMinutes: null };
        Â  Â  });
        Â  Â  setPlayers(newPlayers);
        Â  Â  setMatchPlan('');
          setMatchLineups([]);
          setCurrentLineupIndex(0);
        Â  Â  console.log('Squad loaded.');
        Â  };

        Â  const handleDeleteSquad = async (id) => {
        Â  Â  console.log(`Squad deletion requested for ID: ${id}`);
        Â  Â Â 
        Â  Â  setIsSavingLoading(true);
        Â  Â  try {
        Â  Â  Â  const collectionRef = db.collection(firestorePath);
        Â  Â  Â  const docRef = db.doc(collectionRef, id);
        Â  Â  Â  await retryFetch(() => db.deleteDoc(docRef));
        Â  Â  Â  console.log('Squad deleted successfully.');
        Â  Â  Â  fetchSquads();
        Â  Â  } catch (e) {
        Â  Â  Â  console.error('Error deleting squad:', e);
        Â  Â  } finally {
        Â  Â  Â  setIsSavingLoading(false);
        Â  Â  }
        Â  };


        Â  const handleGeneratePlan = () => {
        Â  Â  if (activePlayers.length < outfieldSpots + 1) {
        Â  Â  Â  setMatchPlan('Error: Not enough players to fill the formation spots.');
              setMatchLineups([]);
        Â  Â  Â  return;
        Â  Â  }
        Â  Â  if (!settings.matchDuration || settings.matchDuration <= 0) {
        Â  Â  Â  setMatchPlan('Error: Match duration must be greater than zero.');
              setMatchLineups([]);
        Â  Â  Â  return;
        Â  Â  }

        Â  Â  setIsGenerating(true);
        Â  Â  setMatchPlan('');
          setMatchLineups([]);
          setCurrentLineupIndex(0);

        Â  Â  setTimeout(() => {
        Â  Â  Â  try {
        Â  Â  Â  Â  const playersWithCalculatedMinutes = calculateEqualMinutes(settings, displayedPlayers);

        Â  Â  Â  Â  let planResult;
        Â  Â  Â  Â  if (settings.planType === 'Automatic') {
        Â  Â  Â  Â  Â  planResult = generateAutomaticPlan(settings, playersWithCalculatedMinutes);
        Â  Â  Â  Â  } else {
        Â  Â  Â  Â  Â  // Manual Plan Placeholder (Still generates a starting lineup visual)
                  const gkPlayer = playersWithCalculatedMinutes.find(p => p.role === 'GK');
                  const outfieldStarters = playersWithCalculatedMinutes.filter(p => p.role !== 'GK').slice(0, outfieldSpots);
                  const positions = getOutfieldSlots(settings.gameFormat, settings.selectedFormation);

                  const startingLineupPlayers = playersWithCalculatedMinutes.map(p => ({
                      ...p,
                      position: p.role === 'GK' ? 'GK' : (outfieldStarters.find(pl => pl.id === p.id) ? positions[outfieldStarters.findIndex(pl => pl.id === p.id)] : 'Bench')
                  }));

        Â  Â  Â  Â  Â  let planText = `--- Manual Plan Creation (Premiership Only) ---\n\n`;
        Â  Â  Â  Â  Â  planText += `To create a manual plan, you would use interactive controls here to define which player subs on and off at which minute. The plan below shows the starters.\n\n`;
        Â  Â  Â  Â  Â  planText += `GK: ${gkPlayer ? gkPlayer.name : 'Unassigned GK'}\n`;
        Â  Â  Â  Â  Â  positions.forEach((pos, i) => {
        Â  Â  Â  Â  Â  Â  planText += `${pos}: ${outfieldStarters[i]?.name || 'N/A'}\n`;
        Â  Â  Â  Â  Â  });

                  planResult = { planText, lineups: [{ time: '0:00 (Start)', players: startingLineupPlayers }] };
        Â  Â  Â  Â  }

        Â  Â  Â  Â  let finalPlanText = planResult.planText;
                
                // --- Minutes Summary ---
                const minutesSummary = playersWithCalculatedMinutes
                    .filter(p => p.name.trim() !== '')
                    .sort((a, b) => {
                        if (a.role === 'GK' && b.role !== 'GK') return -1;
                        if (a.role !== 'GK' && b.role === 'GK') return 1;
                        return a.name.localeCompare(b.name);
                    })
                    .map(p => `${p.name} (${p.role}): ${p.minutes} mins${p.manualMinutes !== null ? ' (Manual)' : ''}`)
                    .join('\n');
                
                finalPlanText += `\n\n--- PLAYER MINUTES SUMMARY ---\n\n`;
                finalPlanText += minutesSummary;
                finalPlanText += `\n\n------------------------------\n\n`;


        Â  Â  Â  Â  setMatchPlan(finalPlanText);
              setMatchLineups(planResult.lineups);
        Â  Â  Â  } catch (e) {
        Â  Â  Â  Â  setMatchPlan(`An error occurred during plan generation: ${e.message}`);
        Â  Â  Â  Â  console.error('Generation Error:', e);
        Â  Â  Â  } finally {
        Â  Â  Â  Â  setIsGenerating(false);
        Â  Â  Â  }
        Â  Â  }, 500);
        Â  };

        Â  // --- Render ---

        Â  if (error) {
        Â  Â  return <div className="text-red-600 p-4 bg-red-100 rounded-lg m-4">Initialization Error: {error}</div>;
        Â  }
        Â Â 
        Â  if (!isAuthReady) {
        Â  Â  return (
        Â  Â  Â  <div className="flex justify-center items-center h-screen" style={{ backgroundColor: '#F0F4F8' }}>
        Â  Â  Â  Â  <Loader2 className="w-8 h-8 animate-spin" style={{ color: COLORS.NAVY_BLUE }} />
        Â  Â  Â  Â  <span className="ml-2 font-semibold" style={{ color: COLORS.NAVY_BLUE }}>Authenticating and Initializing...</span>
        Â  Â  Â  </div>
        Â  Â  );
        Â  }

        Â  return (
        Â  Â  <div className="p-4 md:p-8 min-h-screen" style={{ backgroundColor: COLORS.WHITE, fontFamily: 'Inter, sans-serif' }}>
        Â  Â  Â  <header className="flex flex-col md:flex-row justify-between items-center pb-6 border-b-4 mb-6" style={{ borderColor: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  <div className="flex items-center space-x-4">
        Â  Â  Â  Â  Â  <img
        Â  Â  Â  Â  Â  Â  src="https://placehold.co/100x100/193755/AF9542?text=TGGPLOGO" 
        Â  Â  Â  Â  Â  Â  alt="The Girls' Game Plan Logo" 
        Â  Â  Â  Â  Â  Â  className="w-16 h-16 rounded-full shadow-lg"
        Â  Â  Â  Â  Â  />
        Â  Â  Â  Â  Â  <h1 className="text-4xl font-extrabold" style={{ color: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  Â  Â  The Girls' Game Planner
        Â  Â  Â  Â  Â  </h1> 
        Â  Â  Â  Â  </div>
        Â  Â  Â  Â  <SubscriptionBadge tier={subscriptionTier} />
        Â  Â  Â  </header>

        Â  Â  Â  <p className="text-sm font-medium mb-6 p-3 rounded-lg" style={{ backgroundColor: COLORS.SKY_BLUE, color: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  <User className="inline w-4 h-4 mr-1 align-sub" /> User ID: <span className="font-mono text-xs">{userId}</span>
        Â  Â  Â  </p>

        Â  Â  Â  <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        Â  Â  Â  Â  <div className="lg:col-span-1 space-y-6">
        Â  Â  Â  Â  Â  <div className="p-6 rounded-xl shadow-2xl" style={{ backgroundColor: COLORS.NAVY_BLUE, color: COLORS.WHITE }}>
        Â  Â  Â  Â  Â  Â  <h2 className="text-2xl font-bold mb-4 flex items-center"><Settings className="w-6 h-6 mr-2" /> Match Setup</h2>

        Â  Â  Â  Â  Â  Â  <div className="space-y-4">
        Â  Â  Â  Â  Â  Â  Â  <label className="block">Game Format (XvX)</label>
        Â  Â  Â  Â  Â  Â  Â  <select
        Â  Â  Â  Â  Â  Â  Â  Â  value={settings.gameFormat}
        Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setSettings(p => ({ ...p, gameFormat: e.target.value }))}
        Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-lg font-semibold" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  >
        Â  Â  Â  Â  Â  Â  Â  Â  {Object.keys(FORMATIONS).map(f => <option key={f} value={f}>{f}</option>)}
        Â  Â  Â  Â  Â  Â  Â  </select>

        Â  Â  Â  Â  Â  Â  Â  <label className="block pt-2">Match Duration (min)</label>
        Â  Â  Â  Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  Â  Â  Â  type="number"
        Â  Â  Â  Â  Â  Â  Â  Â  value={settings.matchDuration}
        Â  Â  Â  Â  Â  Â  Â  Â  readOnly
        Â  Â  Â  Â  Â  Â  Â  Â  disabled
        Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-lg font-semibold bg-gray-200 cursor-not-allowed" style={{ color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  />
        Â  Â  Â  Â  Â  Â  Â  <p className="text-xs text-white/70 mt-1">Duration is set automatically based on FA guidelines for {settings.gameFormat}.</p>

        Â  Â  Â  Â  Â  Â  Â  {settings.gameFormat === '5v5' && (
        Â  Â  Â  Â  Â  Â  Â  Â  <div className="pt-2">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block">5v5 Match Periods</label>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex space-x-4">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="radio"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  checked={settings.matchPeriods === 'Halves'}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={() => setSettings(p => ({ ...p, matchPeriods: 'Halves' }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="mr-2"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  /> Halves (2 x 20 min)
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="radio"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  checked={settings.matchPeriods === 'Quarters'}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={() => setSettings(p => ({ ...p, matchPeriods: 'Quarters' }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="mr-2"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  /> Quarters (4 x 10 min)
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </label>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  )}

        Â  Â  Â  Â  Â  Â  Â  <label className="block pt-2">Squad Size</label>
        Â  Â  Â  Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  Â  Â  Â  type="number"
        Â  Â  Â  Â  Â  Â  Â  Â  min={outfieldSpots + (settings.isPermanentGK ? 1 : 0)}
        Â  Â  Â  Â  Â  Â  Â  Â  value={settings.squadSize}
        Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => {
        Â  Â  Â  Â  Â  Â  Â  Â  Â  const val = e.target.value;
        Â  Â  Â  Â  Â  Â  Â  Â  Â  const parsedVal = val === '' ? 0 : parseInt(val, 10);
        Â  Â  Â  Â  Â  Â  Â  Â  Â  setSettings(p => ({ ...p, squadSize: parsedVal }));
        Â  Â  Â  Â  Â  Â  Â  Â  }}
        Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-lg font-semibold" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  />

        Â  Â  Â  Â  Â  Â  Â  <label className="block pt-2">Goalkeeper Rotation</label>
        Â  Â  Â  Â  Â  Â  Â  <div className="flex space-x-4">
        Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="radio"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  checked={settings.isPermanentGK}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={() => setSettings(p => ({ ...p, isPermanentGK: true, gkRotation: false }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="mr-2"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  /> Permanent GK
        Â  Â  Â  Â  Â  Â  Â  Â  </label>
        Â  Â  Â  Â  Â  Â  Â  Â  <label className="flex items-center">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <input
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  type="radio"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  checked={!settings.isPermanentGK}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={() => setSettings(p => ({ ...p, isPermanentGK: false, gkRotation: true }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="mr-2"
        Â  Â  Â  Â  Â  Â  Â  Â  Â  /> Rotating GK
        Â  Â  Â  Â  Â  Â  Â  Â  </label>
        Â  Â  Â  Â  Â  Â  Â  </div>

        Â  Â  Â  Â  Â  Â  Â  <label className="block pt-2">Formation (Outfield Players)</label>
        Â  Â  Â  Â  Â  Â  Â  <select
        Â  Â  Â  Â  Â  Â  Â  Â  value={settings.selectedFormation}
        Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setSettings(p => ({ ...p, selectedFormation: e.target.value }))}
        Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-lg font-semibold" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  >
                        {formationsAvailable.map(f => <option key={f.name} value={f.name}>{f.name}</option>)}
        Â  Â  Â  Â  Â  Â  Â  </select>
        Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  </div>

        Â  Â  Â  Â  Â  {isChampionship && (
        Â  Â  Â  Â  Â  Â  <div className="p-6 rounded-xl shadow-lg border" style={{ borderColor: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  <h3 className="text-xl font-bold mb-4 flex items-center" style={{ color: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  Â  <Save className="w-5 h-5 mr-2" style={{ color: COLORS.NAVY_BLUE }} /> Squad Management
        Â  Â  Â  Â  Â  Â  Â  </h3>
        Â  Â  Â  Â  Â  Â  Â  <p className="text-sm mb-4" style={{ color: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  Â  {isPremiership ? 'Unlimited Squad Saves' : `Save up to ${maxSquads} Squads`} (Current: {savedSquads.length})
        Â  Â  Â  Â  Â  Â  Â  </p>

        Â  Â  Â  Â  Â  Â  Â  <Button onClick={handleSaveSquad} disabled={isSavingLoading || (!isPremiership && savedSquads.length >= maxSquads)} color={COLORS.SKY_BLUE}>
        Â  Â  Â  Â  Â  Â  Â  Â  {isSavingLoading ? <Loader2 className="w-5 h-5 animate-spin mr-2" /> : 'Save Current Squad'}
        Â  Â  Â  Â  Â  Â  Â  </Button>

        Â  Â  Â  Â  Â  Â  Â  <div className="mt-4 space-y-2 max-h-48 overflow-y-auto custom-scrollbar">
        Â  Â  Â  Â  Â  Â  Â  Â  {savedSquads.map(squad => (
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <div key={squad.id} className="flex justify-between items-center p-2 rounded-lg border" style={{ borderColor: COLORS.SKY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span className="text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>{squad.name} ({squad.data.length} players)</span>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div className="flex space-x-1">
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => handleLoadSquad(squad.data)} className="text-xs px-2 py-1 rounded-full text-white" style={{ backgroundColor: COLORS.ORANGE }}>Load</button>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button onClick={() => handleDeleteSquad(squad.id)} className="text-xs px-2 py-1 rounded-full text-white bg-red-500">Del</button>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  Â  ))}
        Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  )}
        Â  Â  Â  Â  </div>

        Â  Â  Â  Â  <div className="lg:col-span-2 space-y-6">
        Â  Â  Â  Â  Â  <div className="p-6 rounded-xl shadow-2xl bg-white">
        Â  Â  Â  Â  Â  Â  <h2 className="text-2xl font-bold mb-4 flex items-center" style={{ color: COLORS.NAVY_BLUE }}><User className="w-6 h-6 mr-2" /> Player Roster</h2>
        Â  Â  Â  Â  Â  Â  <div className="max-h-96 overflow-y-auto custom-scrollbar">
        Â  Â  Â  Â  Â  Â  Â  {displayedPlayers.map((player, index) => (
        Â  Â  Â  Â  Â  Â  Â  Â  <PlayerInputRow
        Â  Â  Â  Â  Â  Â  Â  Â  Â  key={player.id}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  player={player}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  index={index}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  settings={settings}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  setPlayers={setPlayers}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  subscriptionTier={subscriptionTier}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  allPositions={ALL_POSITIONS}
        Â  Â  Â  Â  Â  Â  Â  Â  />
        Â  Â  Â  Â  Â  Â  Â  ))}
        Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  </div>

        Â  Â  Â  Â  Â  <div className="p-6 rounded-xl shadow-lg bg-white border" style={{ borderColor: COLORS.SKY_BLUE }}>
        Â  Â  Â  Â  Â  Â  <h3 className="text-xl font-bold mb-4" style={{ color: COLORS.NAVY_BLUE }}>Plan Options</h3>
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  <div className="flex space-x-4 mb-6">
                        <div className={`p-4 rounded-lg flex-1 shadow-md border ${settings.planType === 'Automatic' ? 'border-2' : 'border'}`} style={{ borderColor: settings.planType === 'Automatic' ? COLORS.ORANGE : COLORS.NAVY_BLUE }}>
                            <label className="flex items-center font-bold w-full" style={{ color: COLORS.NAVY_BLUE }}>
                                <input
                                type="radio"
                                checked={settings.planType === 'Automatic'}
                                onChange={() => setSettings(p => ({ ...p, planType: 'Automatic' }))}
                                className="mr-3"
                                /> 
                                Automatic (Equal Minutes)
                            </label>
                        </div>

                        <div className={`p-4 rounded-lg flex-1 shadow-md border ${isPremiership ? '' : 'opacity-50 cursor-not-allowed'}`} style={{ borderColor: settings.planType === 'Manual' ? COLORS.ORANGE : COLORS.NAVY_BLUE }}>
                            <label className={`flex items-center font-bold w-full`} style={{ color: COLORS.NAVY_BLUE }}>
                                <input
                                type="radio"
                                checked={settings.planType === 'Manual'}
                                onChange={() => isPremiership && setSettings(p => ({ ...p, planType: 'Manual' }))}
                                className="mr-3"
                                disabled={!isPremiership}
                                /> 
                                Manual Plan {isPremiership ? '' : '(Premiership Only)'}
                            </label>
                        </div>
        Â  Â  Â  Â  Â  Â  </div>

        Â  Â  Â  Â  Â  Â  {settings.planType === 'Automatic' && (
        Â  Â  Â  Â  Â  Â  Â  <div className={`grid grid-cols-3 gap-4 p-4 rounded-lg border-dashed border ${isPremiership ? '' : 'opacity-50 pointer-events-none bg-gray-50'}`} style={{ borderColor: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  Â  <p className={`col-span-3 text-sm font-semibold mb-2 ${isPremiership ? 'text-gray-700' : 'text-orange-500'}`}>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  {isPremiership ? 'Substitution Frequency (Premiership)' : 'Upgrade to Premiership for Sub Control'}
        Â  Â  Â  Â  Â  Â  Â  Â  </p>
        Â  Â  Â  Â  Â  Â  Â  Â  <div>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>Interval (min)</label>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <select
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={settings.subInterval}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setSettings(p => ({ ...p, subInterval: parseInt(e.target.value, 10) }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-sm" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  disabled={!isPremiership}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  >
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {[5, 8, 10, 15].map(v => <option key={v} value={v}>{v}</option>)}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
        Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  Â  <div>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>First Sub (min)</label>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <select
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={settings.firstSubTime}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setSettings(p => ({ ...p, firstSubTime: parseInt(e.target.value, 10) }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-sm" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  disabled={!isPremiership}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  >
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {[5, 8, 10, 15].map(v => <option key={v} value={v}>{v}</option>)}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
        Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  Â  <div>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <label className="block text-sm font-medium" style={{ color: COLORS.NAVY_BLUE }}>Max Subs (#)</label>
        Â  Â  Â  Â  Â  Â  Â  Â  Â  <select
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value={settings.maxSubs}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  onChange={(e) => setSettings(p => ({ ...p, maxSubs: parseInt(e.target.value, 10) }))}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  className="w-full p-2 rounded-lg text-sm" style={{ backgroundColor: COLORS.WHITE, color: COLORS.NAVY_BLUE }}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  disabled={!isPremiership}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  >
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {[1, 2, 3, 4].map(v => <option key={v} value={v}>{v}</option>)}
        Â  Â  Â  Â  Â  Â  Â  Â  Â  </select>
        Â  Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  Â  Â  )}
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  <Button onClick={handleGeneratePlan} disabled={isGenerating} color={COLORS.ORANGE} className="mt-6 w-full">
        Â  Â  Â  Â  Â  Â  Â  {isGenerating ? <Loader2 className="w-5 h-5 animate-spin mr-2" /> : <Play className="w-5 h-5 mr-2" />}
        Â  Â  Â  Â  Â  Â  Â  {isGenerating ? 'Generating...' : 'Generate Match Plan'}
        Â  Â  Â  Â  Â  Â  </Button>
        Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  </div>
        Â  Â  Â  </div>

        Â  Â  Â  <div className="mt-8">
        Â  Â  Â  Â  <h2 className="text-3xl font-bold mb-4" style={{ color: COLORS.NAVY_BLUE }}>Match Plan Output</h2>

        Â  Â  Â  Â  <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        Â  Â  Â  Â  Â  <div className="p-6 rounded-xl shadow-xl bg-gray-50">
        Â  Â  Â  Â  Â  Â  <h3 className="text-xl font-bold mb-4 border-b pb-2" style={{ color: COLORS.NAVY_BLUE, borderColor: COLORS.SKY_BLUE }}>Substitution Schedule</h3>
        Â  Â  Â  Â  Â  Â  <pre className="whitespace-pre-wrap font-mono text-sm leading-relaxed" style={{ color: COLORS.NAVY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  {matchPlan || 'Press "Generate Match Plan" to see the schedule here. Match info will display the selected periods for 5v5.'}
        Â  Â  Â  Â  Â  Â  </pre>
        Â  Â  Â  Â  Â  </div>

        Â  Â  Â  Â  Â  <div className="p-6 rounded-xl shadow-xl bg-white">
        Â  Â  Â  Â  Â  Â  <h3 className="text-xl font-bold mb-4 border-b pb-2" style={{ color: COLORS.NAVY_BLUE, borderColor: COLORS.SKY_BLUE }}>
        Â  Â  Â  Â  Â  Â  Â  Live Formation Visual
        Â  Â  Â  Â  Â  Â  </h3>
                        
                    {/* PremiereShip Sub Timeline */}
                    {isPremiership && matchLineups.length > 1 && (
                        <SubstitutionTimeline 
                            lineups={matchLineups}
                            currentLineupIndex={currentLineupIndex}
                            setCurrentLineupIndex={setCurrentLineupIndex}
                        />
                    )}
                    {/* Main Visualizer */}
        Â  Â  Â  Â  Â  Â  {settings.selectedFormation && (
        Â  Â  Â  Â  Â  Â  Â  <PositionVisualizer 
                            settings={settings} 
                            lineups={matchLineups.length > 0 ? matchLineups : [{ players: displayedPlayers.map(p => ({...p, position: p.preferredPosition || 'Bench'})), time: 'Current Roster'}]} 
                            currentLineupIndex={currentLineupIndex}
                            isPremiership={isPremiership}
                        />
        Â  Â  Â  Â  Â  Â  )}
        Â  Â  Â  Â  Â  </div>
        Â  Â  Â  Â  </div>
        Â  Â  Â  </div>

        Â  Â  </div>
        Â  );
        };

        // Render the application into the 'root' div
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
